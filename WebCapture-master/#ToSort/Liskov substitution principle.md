# Liskov substitution principle

_Captured: 2015-10-24 at 19:39 from [en.m.wikipedia.org](https://en.m.wikipedia.org/wiki/Inheritance_semantics)_

**Substitutability** is a principle in [object-oriented programming](https://en.m.wikipedia.org/wiki/Object-oriented_programming). It states that, in a [computer program](https://en.m.wikipedia.org/wiki/Computer_program), if S is a [subtype](https://en.m.wikipedia.org/wiki/Subtype) of T, then objects of [type](https://en.m.wikipedia.org/wiki/Datatype) T may be replaced with objects of type S (i.e., objects of type S may _substitute_ objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.). More formally, the **Liskov substitution principle** (**LSP**) is a particular definition of a [subtyping](https://en.m.wikipedia.org/wiki/Subtyping) relation, called **(strong) behavioral subtyping**, that was initially introduced by [Barbara Liskov](https://en.m.wikipedia.org/wiki/Barbara_Liskov) in a 1987 conference [keynote](https://en.m.wikipedia.org/wiki/Keynote) address entitled _Data abstraction and hierarchy_. It is a [semantic](https://en.m.wikipedia.org/wiki/Formal_semantics_of_programming_languages) rather than merely syntactic relation because it intends to guarantee semantic interoperability of [types](https://en.m.wikipedia.org/wiki/Data_type) in a hierarchy, [object types](https://en.m.wikipedia.org/wiki/Object_\(computer_science\)) in particular. [Barbara Liskov](https://en.m.wikipedia.org/wiki/Barbara_Liskov) and [Jeannette Wing](https://en.m.wikipedia.org/wiki/Jeannette_Wing) formulated the principle succinctly in a 1994 paper as follows:

    _Let Φ(x) be a property provable about objects x of type T. Then Φ(y) should be true for objects y of type S where S is a subtype of T._

In the same paper, Liskov and Wing detailed their notion of behavioral subtyping in an extension of [Hoare logic](https://en.m.wikipedia.org/wiki/Hoare_logic), which bears a certain resemblance with [Bertrand Meyer](https://en.m.wikipedia.org/wiki/Bertrand_Meyer)'s [Design by Contract](https://en.m.wikipedia.org/wiki/Design_by_Contract) in that it considers the interaction of subtyping with [preconditions](https://en.m.wikipedia.org/wiki/Precondition), [postconditions](https://en.m.wikipedia.org/wiki/Postcondition) and [invariants](https://en.m.wikipedia.org/wiki/Invariant_\(computer_science\)).

Liskov's notion of a behavioral subtype defines a notion of substitutability for [mutable](https://en.m.wikipedia.org/wiki/Mutable) objects; that is, if _S_ is a subtype of _T_, then objects of type _T_ in a program may be replaced with objects of type _S_ without altering any of the desirable properties of that program (e.g., [correctness](https://en.m.wikipedia.org/wiki/Correctness_\(computer_science\))).

Behavioral subtyping is a stronger notion than typical [subtyping of functions](https://en.m.wikipedia.org/wiki/Subtyping_of_functions) defined in [type theory](https://en.m.wikipedia.org/wiki/Type_theory), which relies only on the [contravariance](https://en.m.wikipedia.org/wiki/Covariance_and_contravariance_\(computer_science\)) of argument types and [covariance](https://en.m.wikipedia.org/wiki/Covariance_and_contravariance_\(computer_science\)) of the return type. Behavioral subtyping is trivially [undecidable](https://en.m.wikipedia.org/wiki/Undecidable_problem) in general: if _q_ is the property "method for _x_ [always terminates](https://en.m.wikipedia.org/wiki/Halting_problem)", then it is impossible for a program (e.g., a compiler) to verify that it holds true for some subtype _S_ of _T_, even if _q_ does hold for _T_. Nonetheless, the principle is useful in reasoning about the design of class hierarchies.

Liskov's principle imposes some standard requirements on [signatures](https://en.m.wikipedia.org/wiki/Type_signature) which have been adopted in newer object-oriented programming languages (usually at the level of classes rather than types; see [nominal vs. structural subtyping](https://en.m.wikipedia.org/wiki/Subtype) for the distinction):

  * [Contravariance](https://en.m.wikipedia.org/wiki/Covariance_and_contravariance_\(computer_science\)) of method arguments in the subtype.
  * No new exceptions should be thrown by methods of the subtype, except where those exceptions are themselves subtypes of exceptions thrown by the methods of the supertype.

In addition to the signature requirements, the subtype must meet a number of behavioral conditions. These are detailed in a terminology resembling that of [design by contract](https://en.m.wikipedia.org/wiki/Design_by_contract) methodology, leading to some restrictions on how contracts can interact with [inheritance](https://en.m.wikipedia.org/wiki/Inheritance_\(computer_science\)):

  * [Preconditions](https://en.m.wikipedia.org/wiki/Precondition) cannot be strengthened in a subtype.
  * [Invariants](https://en.m.wikipedia.org/wiki/Invariant_\(computer_science\)) of the supertype must be preserved in a subtype.
  * History constraint (the "history rule"). Objects are regarded as being modifiable only through their methods ([encapsulation](https://en.m.wikipedia.org/wiki/Encapsulation_\(computer_science\))). Since subtypes may introduce methods that are not present in the supertype, the introduction of these methods may allow state changes in the subtype that are not permissible in the supertype. The history constraint prohibits this. It was the novel element introduced by Liskov and Wing. A violation of this constraint can be exemplified by defining a _mutable point_ as a subtype of an _immutable point_. This is a violation of the history constraint, because in the history of the _immutable point_, the state is always the same after creation, so it cannot include the history of a _mutable point_ in general. Fields added to the subtype may however be safely modified because they are not observable through the supertype methods. Thus, one can derive _a circle with fixed center but mutable radius_ from _immutable point_ without violating LSP.

The rules on pre- and postconditions are identical to those introduced by Bertrand Meyer in his 1988 book _[Object-Oriented Software Construction](https://en.m.wikipedia.org/wiki/Object-Oriented_Software_Construction)_. Both Meyer, and later Pierre America, who was the first to use the term _behavioral subtyping_, gave [proof-theoretic](https://en.m.wikipedia.org/wiki/Proof-theoretic) definitions of some behavioral subtyping notions, but their definitions did not take into account [aliasing](https://en.m.wikipedia.org/wiki/Aliasing_\(computing\)) that may occur in programming language that supports references or pointers. Taking aliasing into account was the major improvement made by Liskov and Wing (1994), and a key ingredient is the history constraint. Under the definitions of Meyer and America, a MutablePoint would be a behavioral subtype of ImmutablePoint, whereas LSP forbids this.

A typical example that violates LSP is a Square class that derives from a Rectangle class, assuming getter and setter methods exist for both width and height. The Square class always assumes that the width is equal with the height. If a Square object is used in a context where a Rectangle is expected, unexpected behavior may occur because the dimensions of a Square cannot (or rather should not) be modified independently. This problem cannot be easily fixed: if we can modify the setter methods in the Square class so that they preserve the Square invariant (i.e., keep the dimensions equal), then these methods will weaken (violate) the [postconditions](https://en.m.wikipedia.org/wiki/Postcondition) for the Rectangle setters, which state that dimensions can be modified independently. Violations of LSP, like this one, may or may not be a problem in practice, depending on the postconditions or invariants that are actually expected by the code that uses classes violating LSP. Mutability is a key issue here. If Square and Rectangle had only getter methods (i.e., they were [immutable objects](https://en.m.wikipedia.org/wiki/Immutable_object)), then no violation of LSP could occur.
