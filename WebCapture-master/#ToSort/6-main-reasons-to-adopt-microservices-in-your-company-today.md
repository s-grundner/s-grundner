# 6 Main Reasons to Adopt Microservices in Your Company Today

_Captured: 2017-10-10 at 20:19 from [dzone.com](https://dzone.com/articles/06-main-reasons-to-adopt-microservices-in-your-com-1?edition=329552&utm_source=Daily%20Digest&utm_medium=email&utm_campaign=Daily%20Digest%202017-10-10)_

Share, secure, distribute, control, and monetize your APIs with the platform built with performance, time-to-value, and growth in mind. [Free 90-day trial](https://dzone.com/go?i=231226&u=https%3A%2F%2Fwww.redhat.com%2Fen%2Ftechnologies%2Fjboss-middleware%2F3scale%2Fget-started%3Fsc_cid%3D701f2000000h30LAAQ) of 3Scale by Red Hat

_Microservices architecture style is no longer hype by now._

Big players and several industry movements recently are fostering the focus and then the adoption of this important concept throughout a big range of software application solutions, such as

  * Financial Services
  * Insurance Services
  * IoT Solutions

In this article, we will highlight the main drivers that are common sense in the industry today in order to you adopt and start working with Microservices from now on:

## Fast Spin to Release New Solutions (AKA Faster Time to Market)

_Microservices embrace automation._

Once you have a plausible pipeline to package and deliver your Microservices ([CD](https://continuousdelivery.com)/[CI](https://www.thoughtworks.com/continuous-integration)) with any automation suite you want or have today, you should be able to obtain the best advantages of this approach since the beginning, since the first Microservices you deliver in Production.

Automation is key if you are planning to expand the number of Microservices in your solution in the future, a normal way to do once you start to break down your current monolith. It will support the evolution that is inherited with the adoption of this architectural style.

It's key because you need to assure the delivery quality level in the final product. With proper automation and control, you can achieve the desired result in a faster way.

## Small Teams to Code and Deploy (Team Empowerment)

With the concept of dedicated and powered teams that are responsible for all aspects and codebase of a business context (and thus a microservice), after some time, you should see a natural positive performance in delivering new features and business value for a particular Microservice.

![](https://cdn-images-1.medium.com/max/720/0*1dd26kiRMiHFuehs.png)

_Microservices can have dedicated teams for two different microservices that need to communicate with each other._

The team's mindset around that specific business context (Boundary Context / Domain Driven Design concept) should evolve naturally due to daily business challenges and demands that occur. It's normal that their expertise grows more and more each time.

Giving the needed freedom of choice to the team so it can define the best way to deliver the business service required.

The team will embrace the changes and deliver it accordingly.

## Ease of Maintainance

Once you have specific and smaller teams to evolve and admin the Microservices and the segmented codebase per Microservice, the minimum changes you place in the code will not put the whole solution down because of cross-reference in compile time or runtime.

You will not have to rebuild the whole solution because you edited a single dependency that is really used in another module. This is past.

Testing should be easier as well (up to some point) once you have the specific business scope to test and vaildate.

## Independent Scalability of Components

Microservices run in separated execution units, called _containers_. Containers deliver all resources needed by services.

For each Microservice, you should have a dedicated container that supports it. That's why the automation, in this case, is so important (not only to package and testing) but as well to deliver the final product, with all resources that are needed by the service, delivered in the format of a container with the Microservice embedded in it.

Once you deliver the container, you can scale it in an independent way, each container with its only level of scalability, according to the needs of the solution as a whole.

One question that arises at this point is: _how can we guarantee for sure when to scale a Microservice. How can we monitor any Microservices so we can scale it appropriately?_

The answer to this question remains in the scope of some Design Patterns for Microservices that will be covered in future posts in this channel. Right now you should realize that is natural within the Microservices architecture to address this kind of problem, in a seamlessly way.

## Programming Language Free of Choice

_Microservices implementation is flexible._

Each Microservice can be written in a different programming language, just because they run separately and communicate effectively via well-defined interfaces over well-known protocols.

![](https://cdn-images-1.medium.com/max/720/0*I4jd0kG52LWF7WSI.png)

> _Microservices can be implemented in different programming languages._

The most common programming languages/frameworks used today are [Java](https://docs.oracle.com/javase/8/docs/technotes/guides/language/index.html), [.NET](https://www.microsoft.com/net/), [Go (Golang)](https://golang.org/), [Java Script/Node.JS](https://nodejs.org/en/) and [Python](https://www.python.org/).

This gives flexibility to the solution once you can explore the best approaches and features of each programming language.

## Microservices Should Be Simple

They are made with only one object in mind. Simplicity.

As Einstein said: "_[Everything should be made as simple as possible, but no simpler](https://quoteinvestigator.com/2011/05/13/einstein-simple/)."_

Of course, this simplicity comes with a price, but you should vouch for microservices architecture and design your solutions in it with all the benefits it brings to you. Do the trade-off by yourself and you will see the advantages of it.

Microservices should address a specific business domain and deliver great business value through its well-defined and public and API documentation.

In essence, these are the main drivers that we believe you should consider when you start thinking about a new solution design using the microservices architecture (MSA) style.

Thanks for reading.

Best regards.

Explore the core elements of owning an API strategy and best practices for effective API programs. [Download](https://dzone.com/go?i=231227&u=https%3A%2F%2Fengage.redhat.com%2F3scale-api-owners-s-201706160312%3Fsc_cid%3D701f2000000h30LAAQ) the API Owner's Manual, brought to you by 3Scale by Red Hat

Opinions expressed by DZone contributors are their own.
