# How to Use Python Modules

_Captured: 2017-04-12 at 20:11 from [dzone.com](https://dzone.com/articles/import-create-install-upgrade-alias-and-reload-pyt?edition=290884&utm_source=Daily%20Digest&utm_medium=email&utm_campaign=dd%202017-04-12)_

Need to build an application around your data? [Learn more](http://hubs.ly/H06Pr9h0) about dataflow programming for rapid development and greater creativity.

One of the biggest advantages when using Python is the large amount of the available modules. There are Python modules for almost everything you need. Whether you need to work with robots or some hardware in a spaceship, you will find a Python module for that.

In this post, we will talk about Python modules and how to create, install, upgrade, reload, and alias them.

## What Is the Python Module?

The Python module allows you to organize your Python code so that your code is easier to understand and easier to maintain later. Put simply, a module is a file consisting of Python programming. Inside a module, you can define functions, classes, and variables. You can send your module to your friends and share it with others so they can use it.

## Standard Library Modules

Python shipped with a large collection of modules known as the standard library. This collection, over 200 modules large at last count, contains platform-independent support for common programming tasks.

None of these modules are part of the Python language itself, but you can use them by importing the needed modules on any of your files. Because they are standard library modules, you can be sure that they will be available on most platforms on which you will run Python.

These modules can be used by importing them using the `import` statement, as we've seen in the previous post on [Python programming basics](https://dzone.com/articles/python-programming-basics-with-examples).

## How the Import Statement Works

Some newcomers might think that the `import` statement works like the `include` directive in C or `require` in PHP, but that is far from the truth. In the other languages, it just does textual insertions of one file into another.

In Python, the situation is little different. There are three steps performed the first time a program imports a given file:

  1. **Find** the module's file.
  2. **Compile** it to bytecode if needed.
  3. **Run** the module's code to build the objects.

First, Python must locate the module file referenced by the import statement.

You type the imported file without the extension and without its full directory path.

Then, Python compiles it to bytecode. If the bytecode file (`.pyc`) is older than the source file or was created by a different Python version, Python automatically regenerates the bytecode.

If Python finds only a bytecode file on the search path and no source file for it, it simply loads the bytecode directly. This means that you can ship a program as just bytecode files and avoid sending source.

The final step of the import operation is to execute the generated bytecode.

## Python Search for a Module

As we said earlier, you just type the name of the module without an extension or complete path and Python will take care of the rest.

Where does Python search for the modules?

  * The home directory of your program.
  * PATH environment variable directories.
  * Standard library directories.
  * The contents of any `.pth` files, if found.
  * The site packages home of your third-party extensions.

The combination of these items becomes the `sys.path` list. `sys.path` is the module search path. Python configures it at program startup. You can get your path like this:
    
    
    import sys
    
    print(sys.path)

The result is a list of directories that Python searches on each import of a new file. You can modify the search path for all future imports. This modification can be only for the duration of the script.

`sys.path.append` or `sys.path.insert` will append your path for a single program run only.

When you type import `mymodule`, Python will load any of the following:

  * Source code file named `mymodule.py`.
  * Bytecode file named `mymodule.pyc`.
  * Optimized bytecode file named `mymodule.pyo`.
  * Directory named `mymodule` for package imports.
  * Compiled extension module (like `mymodule.so` on Linux or `mymodule.dll` on Windows).
  * Compiled built-in module coded in C and statically linked into Python.
  * ZIP file component that is automatically extracted when imported.
  * Java class in the Jython version of Python.
  * .NET component written in the IronPython version of Python.

If you have two different files, like `mymodule.py` and`mymodule.dll`, Python will load the first file found in the search path during the left-to-right search of `sys.path`.

But what if Python finds both files in the same directory?

In this case, Python follows a standard picking order, which is not guaranteed to stay the same over time. So, stay away from doing that.

## Creating a Python Module

To create a Python module, nothing special is required, just open your editor and type your code and save your file with the `.py` extension.

All the names assigned at the top level of the module become its attributes.

For example, if you define a function like the following inside your module:
    
    
    def myfunc:
    
        print("welcome")

You can call `myfunc` from that imported module inside your code.

Keep in mind that when creating a module, the module name becomes a variable (without the extension) inside your Python program, so you can't name a module `if.py`. Always avoid Python-reserved keywords.

## Installing Python Modules From Source

Many modules are written to use a system called Distutils, which is included with Python. Distutils is a very basic system that is included with Python.

The module includes a special file called `setup.py` that handles the details.

You can install Python modules from the source with `$ python setup.py install`.

This command will install the module within the site-packages folder which could be like `C:\Python27\lib\site-packages` or like `C:\Users\LikeGeeks\AppData\Local\Programs\Python\Python36-32\lib\site-packages`.

## Installing Python Modules Using Pip

The utility `pip` offers the ability to easily install modules and packages directly from the PyPI repository. Most developers prefer installing modules using this method. The best thing about `pip` is that it handles dependency checking.

You can install python modules using `pip` with `$ pip install numpy`.

Also, you can upgrade your installed modules using pip with `$ pip install --upgrade numpy`.

This command will update all the dependencies of the modules.

## Importing Modules

After writing your awesome modules or installing them, let's say you need to reuse it in your code, send it to your friends so they can use it, or share it with others on the web. How can you import modules in your code?

There are two ways to achieve that. The first way is to use the `import` statement, and the second way is to use the `from` statement. Both of them will find, compile, and run.

The major difference is that `import` fetches the whole module, while `from` fetches the specified attributes from the modules.
    
    
    import mymodule
    
    from mymodule import myfunc

### The Import Statement

Because the `import` statement loads all attributes from the module, you must go through the module name to fetch its attributes.
    
    
    import mymodule
    
    mymodule.myfunc()

### The From Statement

As we said before, the `from` statement loads only the specified attributes.

Using the `from` statement makes for less typing because we don't have to specify the whole module name when calling it.
    
    
    from mymodule import myfunc
    
    myfunc()

Actually, behind the scenes, `from` is an extension of `import`. The entire file is also loaded, but you will be provided with all attributes directly from your code.

You can write the `from` statement with `from mymodule import *`.

`*` here means import everything at the top level from the module.

The `from` statement copies all names in the module into the importing space.

## The Danger of Using From Statement

Some Python developers recommend using the `import` statement over using the `from` statement.

But is this right? Is the `from` statement not safe?

Well, if you use the `from` statement to import variables that happen to have the same names as existing variables in your scope, then your variables will be silently overwritten.

This problem, of course, doesn't happen with the `import` statement. Since you type the module name to get its attributes, no collision happens. You should take care when using the `from` statement. Consider the following situation:
    
    
    #Module1
    def myfunc:
    
        print("Hello from module 1")
    
    
    #module2
    
    def myfunc:
    
        print("Hello from module 2")

Now, let's import the above modules and try to use them:
    
    
    from module1 import myfunc
    
    from module2 import myfunc
    
    myfunc()

The output here will be from module2 since the function will be overwritten. This is not a common thing to encounter, but there is still a solution.

## Using Aliases

To avoid the name collision happened in the above example, you can use aliases like this:
    
    
    #MyCode
    
    from module1 import myfunc as myfunc1
    
    from module2 import myfunc as myfunc2
    
    myfunc1()
    
    myfunc2()

It's like renaming the imports. Sometimes, developers use aliases to shorten module names that they are importing when the module name is bigger.

After using aliases, do you think that using the from statements is dangerous? In my opinion, it's not.

## Import Module Scope

You know that we can't access the module attributes unless we import it.

Consider the following situation:
    
    
    #module1
    
    M = 10
    
    def  myfunc():
    
        global M
    
        M = 20
    
    
    #module2
    
    M = 50
    
    import module1
    
    module1.myfunc()
    
    print(M,module1.M)

When you run module2, `module1.myfunc()` changes the `M` variable in module1 -- not in module2.

The result will be `50 20`.

That means that the global scope for `module1.myfunc` is the file that encloses it, not the file it runs from.

The `import` statements don't promote the visibility of the attributes, and the imported file can't see the attributes in the importing file.

## Reloading Modules

Python modules are loaded and run on the first import -- and the first import only. If you try to import the module again, Python will fetch the already loaded module again.

To reload a module, you can use the `reload function` to achieve that. Why do we need to reload the imported module?

The answer is simple. This allows some parts of your program to be modified without restarting your program. You can imagine any situation that needs dynamic customization.

Python can only reload modules written in Python only. So, compiled extensions (like discussed previously) can't be reloaded.

You _must_ import the module first before you reload it. You can reload modules like this:
    
    
    import module1
    
    module1.myfunc()
    
    from importlib import reload
    
    reload(module1)
    
    module1.myfunc()

You can change the code of `module1` in your text editor and it will be reloaded. Reloading modules is a very powerful feature in Python -- if it is used carefully.

I hope you found this post useful and interesting. Keep coming back!

[Check out](http://hubs.ly/H06Pr9h0) the Exaptive data application Studio. Technology agnostic. No glue code. Use what you know and rely on the community for what you don't. [Try the community version](https://exaptive.city/#/landing?referrer=General).

### Like This Article? Read More From DZone
