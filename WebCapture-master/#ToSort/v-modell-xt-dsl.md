# Figure 4: V-Modell XT DSL

_Captured: 2017-07-08 at 10:33 from [www.researchgate.net](https://www.researchgate.net/figure/228842189_fig1_Figure-4-V-Modell-XT-DSL)_

![Figure 4: V-Modell XT DSLÂ 
                ](https://www.researchgate.net/profile/Marco_Kuhrmann/publication/228842189/figure/fig1/AS:300831489445895@1448735224503/Figure-4-V-Modell-XT-DSL.png)

## Context

Architecture. PDE's architecture [25] basically consists of a family of (meta-)models that are implemented by DSLs as shown in Figure 2. The core model of PDE is the Language Meta- Model that describes the domain of software development processes, used to specify the Domain Meta-Model , which is the representation of a concrete (process meta-) model (e.g. SPEM). The domain meta-model's structure is further used to automatically generate the Domain Model as an instance of the domain meta-model for integration with the Tool Framework . The tool framework is an extensible framework used to visualize and modify the domain model. A DSL created with PDE can host multiple view such as model trees, property grids, graphical designer surfaces or error lists (see Figure 4). Because of the multi-layered architecture with each DSL serving a specific purpose, the implementation of a new process model requires a couple of steps shown in Figure 3: 1. Specification of the domain meta-model. 2. Generation of the domain model and integration into the tool framework. 3. Applying optional extensions. 4. Building the editor. The first step is done using the Language DSL Designer , which is a Microsoft Visual Studio extension. If the meta-model of the process is already explicitly written down, this step means to translate the meta-model of the process to the domain meta-model of PDE. In the case of the V-Modell XT, it meant to translate the V-Modell XT's XML schema definition to the domain meta-model. The second step generates code from the domain meta-model using T4 templates [22]. The generated code can either be used as is or it can be extended - for example with custom validation rules or extensions (step 3). The "language engineer" can decide on the degree of modeling and which extensions will be available to the user. It is possible for instance to implement validation using functional programming languages such as F# instead of modeling a 5 constraint (due to the ability of the .NET platform to mix several languages). An example of a coded validation rule is a checking algorithm for a graph being free of cycles. A plugin for PDE can can be basic and only define additional functionality or it can provide custom views and editors that are integrated in the PDE main application. After customization and extension, PDE can be built in step 4. This results in the PDE editor application (in Figure 4) for the specified model. Research Questions. PDE is a fully functional application with functionality already going beyond the possibilities of standard tools. Yet, there is plenty of room for further work: Currently, validation constraints are specific to the process model. It would simplify the development of variants for new process models, if validation rules defined in a generic validation language could be reused across models. The same observation is true for serialization: currently, serialization rules have to be specified for each element individually. Another aspect is that it may be useful to combine several models into a larger model. A process engineer may then develop process components and assemble those to the overall process (similar to method libraries in the Eclipse Process Framework [4]). We have yet to gather practical experience on how to deal with model evolution and how it impacts the DSL-based generated working environment. Implementation Statistics. As of June 2010 PDE had a code size of 40 KLOC. Additional 320 KLOC are generated by the T4 templates from the DSLs, adding up to a total code size of 360 KLOC. The readability of the generated portions largely depends on how well the domain model is modeled. If meaningful element names are chosen for the model, the associated source code is human-readable. However, generated and custom code are strictly separated through .NET's mechanism of partial classes, so a developer usually does not have to bother with the generated code other than for debugging of T4 templates. The Process Enactment Tool Framework (PET, [17]) is a process transformation framework that bridges the gap between the defined process and project execution. It provides a generic process intermediate model, which arbitrary processes can be mapped onto and which transformed data can be extracted from. PET applies ideas and concepts of model-driven design & development to process enactment. The input to PET is a machine-readable process description (data model); its output side is usually a process-aware tool that provides some kind of process support to users during project execution. PET thus makes a contribution to the enactment of processes.
