# Linux Iptables Firewall Simplified Examples

_Captured: 2017-03-14 at 18:45 from [dzone.com](https://dzone.com/articles/linux-iptables-firewall-simplified-examples?edition=283881&utm_source=Daily%20Digest&utm_medium=email&utm_campaign=dd%202017-03-14)_

Discover how to [protect your applications](https://dzone.com/go?i=176121&u=http%3A%2F%2Fwww.waratek.com%2Fsolutions%2Fzero-day-defense%2F%3Futm_source%3DDZone%26utm_campaign%3Dba%26utm_medium%3Dprerolltextad%26utm_content%3Dzeroday) from known and unknown vulnerabilities.

In the previous post, we talked about how to [Secure a Linux Server Using Hardening Best Practices](https://likegeeks.com/secure-linux-server-hardening-best-practices/) and some people asked me about the firewall section which was a brief introduction about iptables firewall. Today we will discuss in detail the **Linux iptables firewall** and how to secure our servers traffic using that awesome tool.

## Our Main Points Are:

  * Iptables on CentOS 7
  * How Linux Firewall Work
  * Iptables Firewall Tables
  * Table Chains
  * Chain Policy
  * Adding iptables Rules
  * Iptables Rules Order
  * List iptables Rules
  * Deleting Rules
  * Replacing Rules
  * Listing Specific Table
  * Iptables User Defined Chain
  * Redirection to a User Defined Chain
  * Setting Default Policy for Chains
  * Handling ICMP Traffic
  * Blocking Bad Flags
  * SYN Flooding
  * Drop INVALID State Packets
  * Drop Fragmented Packets
  * Save iptables Rules

## Iptables on CentOS 7

If you are using CentOS 7, you will find that firewalld was introduced to manage iptables, so if you want to go back to iptables you have to stop and mask firewalld

Then install iptables service and enable it:

Then you can start it

`$ systemctl start iptables`

## How Linux Firewall Works

Iptables firewall functions are built on the Netfilter framework that exists in the Linux kernel. Netfilter was written by an awesome guy called Rusty Russell.

Netfilter allows Linux to perform packet filtering and shaping at a kernel level.

There are two types of packet-filtering firewalls that exist: stateful and stateless.

A **stateless** packet filtering firewall examines only the header of a packet for filtering. It sees each packet in isolation and thus has no way to determine if a packet is part of an existing connection or not.

A **stateful** firewall keeps information about the status of the connections passing through it. This allows the firewall to filter on the state of the connection, and this gives more control over the traffic.

Netfilter works by referring to a set of tables. These tables contain chains, and chains contain individual rules.

If the current packet being processed satisfies the selection criteria of a rule, then the action specified by that rule is carried out.

The actions can be: ignore the packet, accept the packet, reject the packet, or pass the packet onto other rules for more processing.

Any network connection between two hosts is a combination of a source IP address, source port, destination IP address, and destination port. Iptables can use these values to filter traffic coming in and out of hosts, as well as protocol types.

Netfilter is controlled and configured by the iptables command.

Before we start writing firewall commands we need to understand the firewall structure a bit so we can write firewall rules easily.

## iptables Firewall Tables

Netfilter has three built-in tables that can hold rules for processing.

The **filter table**, which is the default table used for all rules related to the filtering of your traffic.

The second is **nat table**, which handles NAT rules, and the last is the **mangle table**, which covers a variety of packet alteration functions.

## Table Chains

The iptables rules are broken down into groups called chains. Each table contains default chains that are built into the table.

You can also create your own chains on each table to hold additional rules.

The built-in chains in the filter table are **FORWARD, INPUT**, and **OUTPUT**.

If a packet is coming to the host, then it needs to be evaluated by the rules in the INPUT chain.

If the packet is generated by the host itself and going out, then it needs to be evaluated by the rules in the OUTPUT chain.

The FORWARD chain is used for packets that have entered the host but are destined for some other host.

## Chain Policy

Each chain in the filter table has a policy. A policy is the default action taken.

The policies you can use for packets are **DROP, REJECT**, and **ACCEPT**.

The ACCEPT policy accepts the traffic and allows it to pass through the firewall. The DROP policy discards a packet without notifying the sender. The REJECT policy also discards the packet, but it sends an ICMP packet to the sender to tell him about the rejection.

From a security perspective, you should deny all traffic by default and open the host to only the traffic to which you have explicitly granted access.

DROP for the INPUT and OUTPUT chains means incoming and outgoing traffic are not allowed unless you explicitly add rules to allow the traffic.

## Adding iptables Rules

To add a new rule, you can simply add one to a chain with the iptables command

`$ iptables -A INPUT -i eth0 -p tcp \--dport 80 -d 192.168.1.2 -j ACCEPT`

Let's break this command into pieces so we can understand everything about it.

  * The -A means we are adding a new rule. By default, all new rules are added to the filter table unless you specify another table.

  * The -i flag specifies which device the traffic will use to enter the host. If you do not specify a device then iptables assumes the rule applies to all incoming network traffic from all devices.

  * The -p flag specifies the protocol of the packets you are filtering, which is TCP in our case.

  * The -dport flag tells iptables to select only packets destined for port 80.

  * The -d selects only those packets destined for the specified IP address, 192.168.1.2. If you do not specify a destination IP address, then iptables would apply this rule to all incoming traffic on eth0 regardless of IP address.

  * The last flag in the rule, -j, specifies the action or the **JUMP** action to do, here we are accepting the packets using the accept policy.

The above rule allows incoming HTTP traffic which is on port 80. We can add another rule to allow HTTPS traffic which is on port 443.

`$ iptables -A INPUT -i eth0 -p tcp \--dport 443 -d 192.168.1.2 -j ACCEPT`

Easy right? This time the only difference is the destined port, 443.

Now we allow both HTTP and HTTPS, but this is only the incoming traffic, what about allowing outgoing traffic?

  * The -A flag is now adding these rules to the OUTPUT chain.

  * The -o flag indicates traffic outgoing on the specified interface instead of the -I flag as in the previous rules.

  * The -sport flag, defines the source port from which the HTTP or HTTPS traffic comes from.

You can replace the numeric port number on sport or dport with the service name like HTTP or HTTPS. These services names are defined in the ` /etc/services` file.

It is recommended to use the service name rather than a port number, which makes reading rules easier.

## Iptables Rules Order

When you use the -A flag to add a rule, it is appended to the end of the current rules in a chain. You can also add rules using the -I flag, which adds rules to the top of the chain of current rules. The sequence of the rules matters. The rules are checked in the order they are added. With the -I flag you can also add a rule into a chain using a line number, so we can specify where exactly our rules placed.

Look at the following rules to understand how rules ordering matters:

The first rule accepts all TCP traffic comes to eth0, and the number 1 after the chain means you need to insert the rule in the first line of INPUT chain.

The second rule drops the traffic that enters port 80, and the number 2 after the chain means it is the second rule in the INPUT chain.

What will happen here is the first rule will accept all the traffic then the second rule will be ignored because the first rule already accepts all the traffic so the second rule here makes no sense.

Your rules should make sense, since the order of the rules in the chain matters.

## List iptables Rules

You can list the rules in a chain using -L flag:

`$ iptables -L INPUT`

You can also show the line numbers for rules using -line-numbers:

`$ iptables -L INPUT \--line-numbers`

The list shows the services names, but you can show port numbers instead using -n option:

`$ iptables -L INPUT -n \--line-numbers`

This makes the listing faster as it stops iptables that are waiting for DNS resolution and service lookups.

You can list all rules for all chains like this:

`$ iptables -L -n \--line-numbers`

Each rule has an associated counter that tracks how many bytes and packets have been processed by that rule. You can see these counters using -v flag:

`$ iptables -L -v`

Also, you can reset the counters to zero using -Z flag.

Now we can add a new rule to any chain we want, we can insert the rule in a specific order, and we can list the rules for any chain or all chains. But what about deleting a rule that you no longer need?

## Deleting Rules

You can delete a rule using -D flag:

`$ iptables -D INPUT -i eth0 -p tcp \--dport https -d 192.168.1.2 -j ACCEPT`

This command will delete the HTTPS rule you specified earlier. You must match the exact specifications of the rule to be deleted otherwise the deletion will fail.

So make sure of the rule specification by listing it, and then delete it.

You can delete the rule using the order number instead of writing the rule specifications.

`$ iptables -D INPUT 2`

You can delete all rules in a specific chain using the -F flag, which means flush all rules.

`$ iptables -F INPUT`

If you forget to mention the chain name when using the -F flag then all rules in all chains will be flushed.

## Replacing Rules

You can replace existing rules with your own rule using the -R flag:

`$ iptables -R INPUT 1 -i eth0 -p tcp \--dport https -d 192.168.1.2 -j ACCEPT`

This command will replace the first rule in the INPUT chain with the typed rule.

## Listing Specific Tables

Until now we have listed chains from a filter table which is the default table, as we said. What about listing another table's rules?

You can specify the table using the -t flag:

`$ iptables -L -t nat`

Here we list the rules in the nat table.

## Iptables User Defined Chain

You can create a new chain using the -N flag:

`$ iptables -N MY_CHAIN`

Also, you can rename it using the -E flag:

`$ iptables -E MY_CHAIN NEW_NAME`

And you can delete the user-defined chain using the -X flag:

`$ iptables -X MY_CHAIN`

If you don't mention the chain name when using the -X flag it will delete all user-defined chains.

You can't delete built-in chains like INPUT and OUTPUT.

## Redirection to User Defined Chain

You can redirect packets to a user-defined chain like built-in chains using the -j flag.

`$ iptables -A INPUT -p icmp -j MY_CHAIN`

So all incoming ICMP traffic will be redirected to the newly created chain called MY_CHAIN.

## Setting Default Policy for Chains

You can use the -p flag to set the default policy for a specific chain. The default policy could be ACCEPT, REJECT, and DROP.

`$ iptables -P INPUT DROP`

So now the input chain will drop any packet that comes through unless you write a rule to allow any incoming traffic.

## Handling ICMP Traffic

ICMP provides error, control, and informational messages such as the messages used by the ping command. This is important for network troubleshooting and diagnostics but the attacker can do some malicious things with it, like:

  * Sending a huge amount of ICMP packets that leads to consuming the available bandwidth resulting in a Denial of Service.
  * Sending forged ICMP echo packets to network broadcast addresses. The broadcast addresses reply with ICMP echo reply packets, resulting in a Denial of Service.
  * Sending an ICMP echo packet larger than the maximum IP packet size that may crash your system.

You can prevent all these attacks using iptables firewall.

A good solution is all incoming ICMP traffic should be dropped except responses to outgoing connections. For example, all incoming ping (echo request) packets are dropped, but incoming ping reply (echo reply) packets that are in reply to pings generated on the local host are accepted.

You want to create some chains to hold the ICMP-related rules.

I will create two chains. The first one I have called is ICMP_IN, which handles the incoming ICMP traffic. The second one I will call is ICMP_OUT, which will handle outgoing ICMP traffic. User-created chains allow you to better structure your rules and allow you to group related rules that handle specific traffic types.

Then we will redirect the traffic to those defined chains:

Now when ICMP traffic is received by the INPUT chain, it is directed to the user-created chain ICMP_IN; and when it is received by the OUTPUT chain, it is handled by the ICMP_OUT chain.

The ICMP Message Types are:

0 Echo Reply

3 Destination Unreachable

4 Source Quench

5 Redirect

8 Echo Request

11 Time Exceeded

12 Parameter Problem

13 Timestamp

14 Timestamp Reply

15 Information Request

16 Information Reply

The iptables rules can target individual ICMP messages types by selecting only ICMP traffic with the -p icmp flag in combination with the -icmp-type flag to select the particular ICMP message type.

`$ iptables -A ICMP_IN -p icmp \--icmp-type 8 -j DROP`

Here we add our first rule to the ICMP_IN chain which will drop the echo request.

Now we should write rules to allow inbound echo replies, and time exceeded and destination unreachable messages.

Using the -m state allows you to perform state inspection and matching on the incoming packets, which is one of the key features of a stateful packet-filtering in iptables.

There are four states: NEW, ESTABLISHED, RELATED, or INVALID.

  * The NEW connection state indicates a freshly initiated connection.

  * The ESTABLISHED connection state indicates an existing connection that is in the process of transferring data.

  * The RELATED state refers to a connection that is used to facilitate another connection.

  * The INVALID state refers to a connection that has been seen to have problems in processing packets.

Back to our rules. It does not allow NEW connections using the ICMP to be made. This means attempts to ping this host will result in an error.

Now you add the rules to take care of the outbound ICMP traffic in case you want to ping remote hosts.

`$ iptables -A ICMP_OUT -o eth0 -p icmp \--icmp-type 8 -m state \--state NEW -j ACCEPT`

We are not discussing how to disable ICMP packets here in specific, we are investigating how iptables firewall works. There are a lot of firewalls you can use that build upon iptables, so instead of using a ready-made product without understanding what's going on, you should be able to add your own rules, remove unnecessary ones, or modify existing rules to fit your needs.

## Blocking Bad Flags

When a new TCP connection is created, a process that is commonly referred to as the three-way handshake occurs.

You send an SYN TCP packet, then the receiver sends as a response SYN ACK packet back to you, and then you send an ACK to it. This is the complete three-way handshake.

You can use iptables to select packets with particular TCP flags using the -tcp-flags flag.

`$ iptables -A INPUT -p tcp \--tcp-flags ALL SYN -j DROP`

This rule is telling you to look at all TCP flags (SYN, ACK, FIN, RST, URG, and PSH) and match the packets that have the flag SYN set.

There are some combinations of flags that you want to block with your iptables firewall. These flags are not actually attacks, but rather more likely to be attempted by attackers to determine more information about your server using tools like nmap.

Some of the well-known bad flag combinations are SYN/FIN, which is used by a variety of network scanners to perform operating system detection.

I will start by adding a chain to hold the bad TCP flag rules.

`$ iptables -N BAD_FLAGS`

Then we will redirect all TCP traffic to the bad TCP flags rules to be processed.

`$ iptables -A INPUT -p tcp -j BAD_FLAGS`

When traffic is redirected to a user-defined chain by a rule, it will be processed against all the rules in the new chain and then return to the chain that redirected it to be processed by the next rule in the sequence. So all traffic comes to the BAD_FLAGS chain and then returns it to the INPUT chain.

`$ iptables -A BAD_FLAGS -p tcp \--tcp-flags SYN,FIN SYN,FIN -j DROP`

Other variations on the SYN/FIN flag combination are used for similar purposes.

SYN/RST, SYN/FIN/PSH, SYN/FIN/RST, and SYN/FIN/RST/PSH

We can add rules for those combinations too:

Cool!!

Also, we can't find in normal TCP/IP connections single FIN flag packets, so we can add a rule for that:

`$ iptables -A BAD_FLAGS -p tcp \--tcp-flags FIN FIN -j DROP`

We should also drop null packets. These are generally used for other forms of network probing used by scanning tools such as nmap

## SYN Flooding

The attacker sends a packet with the SYN flag. The receiving host replies with a packet with the SYN/ACK flags. The attacker is not sending an ACK to complete the handshake and that leaves a fully open connection till the connection reaches timeout.

The attacker sends SYN flags and as a result, the receiving host would have many opened connections.

We can use the limit module of iptables firewall to reduce the risk of this sort of attack.

`$ iptables -A INPUT -p tcp -m limit \--limit 10/second -j LOG`

This command logs the tcp packets and limits the logging to ten entries per second.

With the same concept, we can limit the number of incoming SYN packets.

`$ iptables -A INPUT -i eth0 -p tcp \--syn -m limit \--limit 10/second -jACCEPT`

Here we used the special TCP option -syn, which matches all packets with the ACK and RST bits cleared and the SYN flag set. This is the same as -tcp-flags SYN,RST,ACK SYN.

We have limited the number of incoming SYN packets to ten per second. On a busy system, this can cause bottlenecking so this value depends on your network and performance.

If this will throttle your network you can use SYN cookies.

Go into the `/etc/sysctl.conf ` file and add this line:

`net.ipv4.tcp_syncookies = 1`

Then save and reload:

`$ sysctl -p`

## Drop INVALID State Packets

The INVALID state is not associated with any known connection. This means any incoming packets in the INVALID state are not from connections on the host and should be dropped. For example:

`$ iptables -A INPUT -m state \--state INVALID -j DROP`

This rule will cover all incoming packets on all interfaces, and log and drop them.

## Drop Fragmented Packets

Packet fragments occur when a packet is too large to be sent in one piece. The packet is broken up into fragments that are then reassembled on the receiving host.

The -f flag tells iptables firewall to select all fragments. So if you are not using iptables as a router, you can drop fragmented packets.

`$ iptables -A INPUT -f -j DROP`

## Save iptables Rules

All the rules we discussed will be lost if you reboot your server, so how can you save them?

You can save all of your rules using iptables-save command if you are using CentOS or Red Hat.

`$ iptables-save`

You can save specific table like filter table only:

`$ iptables-save -t filter`

Also, you can use iptables-restore to restore rules that were saved.

I hope you find the post useful. There is more to cover about iptables and working with other tables and making iptables work as a router and much more cool stuff, maybe on future posts. Hope you find iptables firewall easy to work with.

Thank you.

Find out how [Waratek's](https://dzone.com/go?i=176122&u=http%3A%2F%2Fwww.waratek.com%2Fsolutions%2Fapplication-protection%2F%3Futm_source%3DDZone%26utm_campaign%3Dba%26utm_medium%3Dpostrolltextad%26utm_content%3Dappprotect) award-winning virtualization platform can [improve your web application security](https://dzone.com/go?i=176122&u=http%3A%2F%2Fwww.waratek.com%2Fsolutions%2Fapplication-protection%2F%3Futm_source%3DDZone%26utm_campaign%3Dba%26utm_medium%3Dpostrolltextad%26utm_content%3Dappprotect), development and operations without false positives, code changes or slowing your application.
