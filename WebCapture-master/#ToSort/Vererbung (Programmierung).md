# Vererbung (Programmierung)

_Captured: 2015-10-24 at 19:43 from [de.m.wikipedia.org](https://de.m.wikipedia.org/wiki/Vererbung_(Programmierung))_

![](http://upload.wikimedia.org/wikipedia/commons/thumb/3/36/InheritancePgmUML.svg/240px-InheritancePgmUML.svg.png)

> _Vererbung dargestellt mittels UML. Die abgeleitete Klasse hat die Attribute x und y und verfugt uber die Methoden a und b (im UML-Sprachgebrauch Operationen a und b)._

Die **Vererbung** ([englisch](https://de.m.wikipedia.org/wiki/Englische_Sprache) _inheritance_) ist eines der grundlegenden Konzepte der [Objektorientierung](https://de.m.wikipedia.org/wiki/Objektorientierung) und hat große Bedeutung in der [Softwareentwicklung](https://de.m.wikipedia.org/wiki/Softwareentwicklung). Die Vererbung dient dazu, aufbauend auf existierenden [Klassen](https://de.m.wikipedia.org/wiki/Klasse_\(Programmierung\)) neue zu schaffen, wobei die Beziehung zwischen ursprunglicher und neuer Klasse dauerhaft ist. Eine neue Klasse kann dabei eine Erweiterung oder eine Einschrankung der ursprunglichen Klasse sein. Neben diesem konstruktiven Aspekt dient Vererbung auch der Dokumentation von Ähnlichkeiten zwischen Klassen, was insbesondere in den fruhen Phasen des [Softwareentwurfs](https://de.m.wikipedia.org/wiki/Softwareentwurf) von Bedeutung ist. Auf der Vererbung basierende Klassenhierarchien spiegeln strukturelle und verhaltensbezogene Ähnlichkeiten der Klassen wider.

Die vererbende Klasse wird meist _[Basisklasse](https://de.m.wikipedia.org/wiki/Basisklasse)_ (auch _Super_-, _Ober_\- oder _Elternklasse_) genannt, die erbende _[abgeleitete Klasse](https://de.m.wikipedia.org/wiki/Abgeleitete_Klasse)_ (auch _Sub_-, _Unter_\- oder _Kindklasse_). Den Vorgang des Erbens nennt man meist _Ableitung_ oder _Spezialisierung_, die Umkehrung hiervon _[Generalisierung](https://de.m.wikipedia.org/wiki/Generalisierung_\(UML\))_, was ein vorwiegend auf die [Modellebene](https://de.m.wikipedia.org/wiki/Modellierungssprache) beschrankter Begriff ist. In der [Unified Modeling Language](https://de.m.wikipedia.org/wiki/Unified_Modeling_Language) (UML) wird eine Vererbungsbeziehung durch einen Pfeil mit einer dreieckigen Spitze dargestellt, der von der abgeleiteten Klasse zur Basisklasse zeigt. Geerbte [Attribute](https://de.m.wikipedia.org/wiki/Attribut_\(Objekt\)) und [Methoden](https://de.m.wikipedia.org/wiki/Methode_\(Programmierung\)) werden in der Darstellung der abgeleiteten Klasse nicht wiederholt.

In der Programmiersprache [Simula](https://de.m.wikipedia.org/wiki/Simula) wurde 1967 die Vererbung mit weiteren Konzepten [objektorientierter Programmierung](https://de.m.wikipedia.org/wiki/Objektorientierte_Programmierung) erstmals eingefuhrt.[[1]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Letztere hat seitdem in der [Softwareentwicklung](https://de.m.wikipedia.org/wiki/Softwareentwicklung) wichtige neue Perspektiven eroffnet und auch die [komponentenbasierte Entwicklung](https://de.m.wikipedia.org/wiki/Komponentenbasierte_Entwicklung) ermoglicht.

[Abgeleitete Klasse](https://de.m.wikipedia.org/wiki/Abgeleitete_Klasse) und [Basisklasse](https://de.m.wikipedia.org/wiki/Basisklasse) stehen typischerweise in einer „ist-ein"-Beziehung zueinander. Klassen dienen der Spezifikation von Datentyp und Funktionalitat, die beide vererbt werden konnen. Einige Programmiersprachen trennen zumindest teilweise zwischen diesen Aspekten und unterscheiden zwischen [Schnittstelle](https://de.m.wikipedia.org/wiki/Schnittstelle_\(Objektorientierung\)) (engl. _Interface_) und Klasse. Wenn eine abgeleitete Klasse von mehr als einer Basisklasse erbt, wird dies [Mehrfachvererbung](https://de.m.wikipedia.org/wiki/Mehrfachvererbung) genannt. Mehrfaches Erben ist nicht bei allen Programmiersprachen moglich, bei manchen nur in eingeschrankter Form.

  * [Besonderheiten bei der Vererbung](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))
![](http://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/InheritancePgmExample.svg/550px-InheritancePgmExample.svg.png)

> _Beispielhaftes Klassendiagramm (UML)_

Das folgende Beispiel stellt einen moglichen Ausschnitt aus dem [Anwendungsgebiet](https://de.m.wikipedia.org/wiki/Problemdom%C3%A4ne) der Unterstutzung eines [Fahrzeugverleihs](https://de.m.wikipedia.org/wiki/Autovermietung) dar. Die Basisklasse `Fahrzeug` enthalt die Attribute `Fahrzeugnummer`, `Leergewicht` und `ZulassigesGesamtgewicht`. Die Spezialisierungen `[Kraftfahrzeug](https://de.m.wikipedia.org/wiki/Kraftfahrzeug)` und `[Fahrrad](https://de.m.wikipedia.org/wiki/Fahrrad)` erganzen weitere Attribute zu den von der Basisklasse geerbten Gewichtsangaben und der [identifizierenden](https://de.m.wikipedia.org/wiki/Identifikator) Fahrzeugnummer. In jedem Objekt der Klasse `Kraftfahrzeug` werden also die Attribute `Fahrzeugnummer`, `Leergewicht`, `ZulassigesGesamtgewicht`, `Hochstgeschwindigkeit` und `Leistung` gespeichert. In der Klasse `Fahrzeug` gibt es die Methode `PruefeVerfuegbarkeit`, die unter Verwendung der `Fahrzeugnummer` die Verfugbarkeit eines bestimmten Fahrzeugs ermittelt, beispielsweise durch einen [Datenbankzugriff](https://de.m.wikipedia.org/wiki/Datenbank). Diese Methode wird von allen Spezialisierungen geerbt und ist somit fur diese ebenfalls nutzbar. Dasselbe gilt auch dann, wenn nachtraglich eine weitere Methode in der Klasse `Fahrzeug` erganzt wird, beispielsweise eine Methode `HatNavigationssystem`, wenn ein Teil der Fahrzeuge mit [Navigationssystemen](https://de.m.wikipedia.org/wiki/Navigationssystem) ausgestattet wird.

In der Klasse `Kraftfahrzeug` wird die [Methode](https://de.m.wikipedia.org/wiki/Methode_\(Programmierung\)) `PrufeFahrerlaubnis` eingefuhrt. Diese Methode soll bei Übergabe einer konkreten [Fahrerlaubnis](https://de.m.wikipedia.org/wiki/Fahrerlaubnis) ermitteln, ob das durch ein Objekt dieser Klasse reprasentierte Fahrzeug mit dieser Fahrerlaubnis gefuhrt werden darf.[[A 1]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Die Fahrerlaubnis konnte landerspezifisch sein, zudem mussen die Lander berucksichtigt werden, in denen das Kraftfahrzeug betrieben werden soll. Auf Basis der Attribute `Hochstgeschwindigkeit` und `Leistung` konnen moglicherweise bereits in der Klasse `[Kraftfahrzeug](https://de.m.wikipedia.org/wiki/Kraftfahrzeug)` einige Implementierungen vorgenommen werden, wenn fur alle betreibbaren Fahrzeuge eines Landes die Eignung der Fahrerlaubnis bereits anhand des [zulassigen Gesamtgewichts](https://de.m.wikipedia.org/wiki/Zul%C3%A4ssige_Gesamtmasse), der Hochstgeschwindigkeit und der Leistung entscheidbar ist. Viele Falle sind aber erst auf Ebene der Spezialisierungen `[Motorrad](https://de.m.wikipedia.org/wiki/Motorrad)`, `[PKW](https://de.m.wikipedia.org/wiki/Personenkraftwagen)` und `[LKW](https://de.m.wikipedia.org/wiki/Lastkraftwagen)` entscheidbar, so dass diese Methode in diesen Klassen u[berschrieben](https://de.m.wikipedia.org/wiki/%C3%9Cberschreiben_\(OOP\)) werden muss. Beispielsweise ist die Anzahl der Sitzplatze des Kraftfahrzeugs in manchen Fallen zu berucksichtigen.

![](http://upload.wikimedia.org/wikipedia/commons/thumb/7/71/InheritancePgmExampleMemory.png/220px-InheritancePgmExampleMemory.png)

> _Schematisches Speicherabbild eines Objekts der Klasse_

Innerhalb eines dieses Modell implementierenden [Anwendungsprogramms](https://de.m.wikipedia.org/wiki/Anwendungsprogramm) wurde zur Prufung, ob eine Fahrerlaubnis gultig ist, nach Eingabe der entsprechenden Fahrzeugdaten das konkrete, zu mietende Fahrzeug instantiiert, das heißt die entsprechende Spezialisierung.

Zudem wurde ebenfalls ein Objekt fur die vorliegende Fahrerlaubnis erzeugt. Dieses wurde der Methode `PrufeFahrerlaubnis` des Fahrzeug-Objekts ubergeben und von dieser ausgewertet. Das Ergebnis der Überprufung konnte beispielsweise dem Sachbearbeiter angezeigt werden. Der Aufbau des Speicherabbilds ist in nebenstehender Abbildung schematisch fur ein Objekt der Klasse `PKW` dargestellt. Die aus den verschiedenen Klassen geerbten Attribute liegen dabei typischerweise direkt hintereinander. Weiterhin enthalt das Speicherabbild eines Objekts einen [Zeiger](https://de.m.wikipedia.org/wiki/Zeiger_\(Informatik\)) auf die sogenannte [Tabelle virtueller Methoden](https://de.m.wikipedia.org/wiki/Tabelle_virtueller_Methoden), die der Ermittlung des [Einsprungspunkts](https://de.m.wikipedia.org/wiki/Einsprungspunkt) der konkreten Implementierung bei einem Methodenaufruf dient.[[2]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Die Vererbung ermoglicht bei der Softwareentwicklung eine [Modellierung](https://de.m.wikipedia.org/wiki/Objektmodell), die der menschlichen Vorstellung von der realen Welt sehr nahe kommt. Es gibt sehr unterschiedliche Anwendungen des Vererbungsmechanismus. Nach wie vor ist umstritten, ob die Vererbung nur fur sehr eng begrenzte Anwendungsbereiche verwendet werden sollte und ob ein Einsatz mit der hauptsachlichen Intention des Wiederverwendens von [Code](https://de.m.wikipedia.org/wiki/Quelltext) der [Softwarequalitat](https://de.m.wikipedia.org/wiki/Softwarequalit%C3%A4t) eher abtraglich ist.[[3]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))[[4]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Folgende Anwendungskontexte werden empfohlen oder tauchen in der Praxis auf:[[4]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))[[5]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

  * _Subtyp-Vererbung:_ Bei dieser ist die erbende Klasse ein Subtyp der Basisklasse im Sinne eines [abstrakten Datentyps](https://de.m.wikipedia.org/wiki/Abstrakter_Datentyp). Dies bedeutet, dass ein Objekt des Subtyps an jeder Stelle eingesetzt werden kann, an der ein Objekt des Basistyps erwartet wird. Die Menge der moglichen Auspragungen des Subtyps stellt eine [Teilmenge](https://de.m.wikipedia.org/wiki/Teilmenge) derer des Basistyps dar.
  * _Vererbung zur Erweiterung:_ In der abgeleiteten Klasse wird neue Funktionalitat gegenuber der Basisklasse erganzt. Diese Variante der Vererbung stellt einen scheinbaren Widerspruch zur einschrankenden Subtyp-Vererbung dar. Die Erweiterung bezieht sich dabei aber auf zusatzliche Attribute.[[A 2]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Diese Variante beinhaltet auch Anpassungen durch Ü[berschreiben](https://de.m.wikipedia.org/wiki/%C3%9Cberschreiben_\(OOP\)) von Methoden, um beispielsweise Funktionalitat zu erganzen, die in der Basisklasse nicht relevant ist. Auch schließt diese Variante den Fall ein, dass nur ein Teil der Funktionalitat einer [abstrakten Klasse](https://de.m.wikipedia.org/wiki/Abstrakte_Klasse) in der abgeleiteten - in diesem Fall ebenfalls abstrakten - Klasse implementiert wird, und zusatzlich erforderliche Implementierungen weiteren Spezialisierungen vorbehalten bleiben _(Reification)_.
  * _Vererbung zur Unterstutzung allgemeiner Fahigkeiten:_ Bei dieser Variante geht es darum, die Unterstutzung von Basisfunktionalitat einer Anwendungsarchitektur oder [Klassenbibliothek](https://de.m.wikipedia.org/wiki/Klassenbibliothek) zu etablieren. Eine Basisfunktionalitat wie [Serialisierbarkeit](https://de.m.wikipedia.org/wiki/Serialisierung) oder [Vergleichbarkeit](https://de.m.wikipedia.org/w/index.php?title=Vergleich_\(Programmierung\)&action=edit&redlink=1) wird dabei durch eine abstrakte Klasse ([Schnittstelle](https://de.m.wikipedia.org/wiki/Schnittstelle_\(Programmierung\))) [deklariert](https://de.m.wikipedia.org/wiki/Deklaration_\(Programmierung\)) - typische Bezeichner sind _Serializable_[[6]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) und _Comparable_[[7]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Die Implementierung aller Anforderungen der Schnittstelle muss in der abgeleiteten Klasse erfolgen. Formal entspricht diese Art der Vererbung der Subtyp-Vererbung.
  * _Vererbung von Standardimplementierungen:_ Allgemeine fur mehrere Typen verwendbare Funktionalitat wird dabei in zentralen Klassen implementiert. Diese Variante dient der zweckdienlichen Wiederverwendung allgemeiner Programmteile ([Mixin-Klasse](https://de.m.wikipedia.org/wiki/Mixin-Klasse)).

Es gibt auch Verwendungen der Vererbung, die nicht als sinnvoll angesehen werden. Insbesondere bei den ersten Gehversuchen in objektorientierter Programmierung ergibt sich haufig eine aus der Begeisterung resultierende ubertriebene Abstufung der Vererbungshierarchie, oft fur eine simple zusatzliche Eigenschaft. Beispielsweise durften fur eine Klasse `Person` die Spezialisierungen `WeiblichePerson` und `MannlichePerson` in den wenigsten Fallen zweckmaßig sein und bei der Modellierung der eigentlich relevanten Aspekte eher behindern. Eine weitere fragwurdige Verwendung ist, wenn die erbende Klasse nicht in einer „ist-ein"\- sondern in einer „hat"-Beziehung zur Basisklasse steht, und eine [Aggregation](https://de.m.wikipedia.org/wiki/Aggregation_\(Informatik\)) angebracht ware. Haufig tritt dieser Fall in Verbindung mit Mehrfachvererbung auf. `Apfelkuchen` als Erbe von `Kuchen` und `Apfel` stellt ein bildhaftes Beispiel dieses Modellierungsfehlers dar, da `Apfel` keine sinnvolle Basisklasse ist.[[4]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

![](http://upload.wikimedia.org/wikipedia/commons/thumb/9/99/InheritancePgmPerson1.svg/220px-InheritancePgmPerson1.svg.png)

> _Ungunstige Modellierung_

![](http://upload.wikimedia.org/wikipedia/commons/thumb/6/60/InheritancePgmPerson2.svg/310px-InheritancePgmPerson2.svg.png)

> _Modellierung mittels Rollen_

Beim Übergang von der [objektorientierten Modellierung](https://de.m.wikipedia.org/wiki/Objektorientierte_Analyse_und_Design) zur [Programmierung](https://de.m.wikipedia.org/wiki/Objektorientierte_Programmierung) gibt es die Situation, dass die Modellierung einer klassifizierenden Hierarchie der fachlichen Anwendungsobjekte nicht ohne weiteres auf die Programmebene ubertragen werden kann. Beispielsweise mag aus konzeptioneller Sicht die Modellierung von `Kunde` und `Mitarbeiter` als Spezialisierungen von `Person` sinnvoll erscheinen. Auf Ebene der Programmierung ist eine solche Klassifizierung zum Einen statisch - das heißt, eine Person kann programmtechnisch nicht ohne weiteres von der Rolle des Mitarbeiters zur Rolle des Kunden wechseln. Zum Anderen kann eine Person auf diese Weise auch nicht mehrere Rollen gleichzeitig einnehmen. Dass letzteres nicht sinnvoll durch Hinzufugen einer mehrfach erbenden, weiteren Spezialisierung `KundeUndMitarbeiter` gelost werden kann, wird beispielsweise bei Hinzunahme einer weiteren Rolle `Lieferant` deutlich. Die ubliche Losung ist die Trennung der Aspekte und die Modellierung einer [assoziativen Beziehung](https://de.m.wikipedia.org/wiki/Assoziation_\(UML\)) zwischen `Person` und ihren Rollen.[[8]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Mittels Vererbung konnen sowohl der Typ, der durch seine Schnittstelle spezifiziert wird, als auch die [Funktionalitat](https://de.m.wikipedia.org/wiki/Funktionalit%C3%A4t) an die abgeleitete Klasse weitergegeben werden. Die Konsequenzen dieser Doppelfunktion der Vererbung werden seit Jahren kontrovers diskutiert.[[3]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))[[4]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Auch neuere Programmiersprachen wie [Java](https://de.m.wikipedia.org/wiki/Java_\(Programmiersprache\)) oder [.NET](https://de.m.wikipedia.org/wiki/.NET)-Sprachen wie [C#](https://de.m.wikipedia.org/wiki/C-Sharp) und [VB.NET](https://de.m.wikipedia.org/wiki/Visual_Basic_.NET) unterstutzen keine durchgangige Trennung dieser Vererbungsvarianten, bieten jedoch fur [Schnittstellen](https://de.m.wikipedia.org/wiki/Schnittstelle_\(Programmierung\)) _(interface)_ und Klassen _(class)_ zwei formal getrennte Konzepte an. Es lassen sich drei Falle unterscheiden:[[9]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

  * Vererbung von Typ und Implementierung (meist _Implementierungsvererbung_ oder einfach nur _Vererbung_ genannt, engl. _Subclassing_)
  * Vererbung des Typs (meist als _Schnittstellenvererbung_ bezeichnet, engl. _Subtyping_)
  * Reine Vererbung der Implementierung (in Java oder .NET-Sprachen nicht direkt moglich)

Bei der letzten Variante stehen abgeleitete Klasse und Basisklasse nicht in einer „ist-ein"-Beziehung zueinander.

Hierbei wird von der Basisklasse die Implementierung und implizit auch deren Schnittstelle geerbt. Die abgeleitete Klasse ubernimmt dabei die Attribute und Funktionalitat der Basisklasse und wandelt diese gegebenenfalls ab oder erganzt diese um weitere fur diese Spezialisierung zusatzlich relevante Eigenschaften. Auch wenn nachtraglich Funktionalitat der Basisklasse erganzt oder verbessert wird, profitiert die abgeleitete Klasse davon.

Im Folgenden wird in der Programmiersprache Java ein Beispiel fur die Ableitung von `[Quadrat](https://de.m.wikipedia.org/wiki/Quadrat_\(Geometrie\))` als Spezialisierung von `Rechteck` skizziert. Dieses Beispiel findet sich in ahnlicher Form haufig in der Literatur und ist zur Veranschaulichung vieler - auch ungunstiger - Aspekte hilfreich, kann aber eigentlich nicht als besonders gutes Beispiel der Vererbung gelten.

Die Klasse `Rechteck` besitzt die Attribute `laenge` und `breite`, die uber den [Konstruktor](https://de.m.wikipedia.org/wiki/Konstruktoren_und_Destruktoren) gesetzt werden. Daneben gibt es [Methoden](https://de.m.wikipedia.org/wiki/Methode_\(Programmierung\)) ([Funktionen](https://de.m.wikipedia.org/wiki/Funktion_\(Programmierung\))) zur Berechnung des Umfangs und der Lange der [Diagonalen](https://de.m.wikipedia.org/wiki/Diagonale_\(Geometrie\)) des Rechtecks. Die Spezialisierung `Quadrat` erbt diese Funktionalitat ([Schlusselwort](https://de.m.wikipedia.org/wiki/Schl%C3%BCsselwort_\(Programmierung\)) `extends`). Der Konstruktor fur `Quadrat` erfordert nur noch einen statt zwei [Parameter](https://de.m.wikipedia.org/wiki/Parameter_\(Informatik\)), da Lange und Breite ja ubereinstimmen. Die in der Klasse `Rechteck` implementierten Berechnungen von Umfang und Diagonalenlange stimmen auch fur das Quadrat. In diesem Beispiel wird dennoch zur Veranschaulichung - aus Optimierungsgrunden - eine Modifikation der Berechnung der Diagonalenlange vorgenommen, da diese bei einem Quadrat auf einfachere Weise berechnet werden kann. Die Berechnung des Umfangs wird nicht reimplementiert, sondern von der Basisklasse ubernommen - obwohl naturlich auch dort eine geringfugige Vereinfachung moglich ware.
    
    
    public class Rechteck
    {
        private double laenge;
        private double breite;
    
        public Rechteck(double laenge, double breite)
        {
            this.breite = breite;
            this.laenge = laenge;
        }
    
        public double getLaenge() { return laenge; }
        public double getBreite() { return breite; }
    
        public double getUmfang()
        {
            return 2 * laenge + 2 * breite;
        }
    
        public double getDiagonale()
        {
            return Math.sqrt(laenge * laenge + breite * breite);
        }
    }
    
    
    
    public class Quadrat extends Rechteck
    {
        // Einmalige Berechnung der Wurzel aus 2
        static final double WURZEL2 = Math.sqrt(2);
    
        public Quadrat(int laenge)
        {
            // Aufruf des Konstruktors der Basisklasse
            super(laenge, laenge);
        }
    
        @Override
        public double getDiagonale()
        {
            return WURZEL2 * getLaenge();
        }
    }
    

In der Softwareentwicklung gab es seit den 1970er Jahren zwei parallele Entwicklungen, eine davon mundete in die [objektorientierte Programmierung](https://de.m.wikipedia.org/wiki/Objektorientierte_Programmierung), andererseits wurden [algebraische](https://de.m.wikipedia.org/wiki/Algebra) Spezifikationsmethoden zur Unterstutzung des Softwareentwurfs entwickelt. Ein Vorteil solcher Spezifikationen ist, dass sie mit einer mathematischen [Semantik](https://de.m.wikipedia.org/wiki/Semantik) versehen werden konnen.[[10]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Ein wesentliches Ergebnis dieser Bestrebungen war das Konzept des [abstrakten Datentyps](https://de.m.wikipedia.org/wiki/Abstrakter_Datentyp), das die Spezifikation eines Datentyps unabhangig von der Implementierung zum Ziel hat. [Klassen](https://de.m.wikipedia.org/wiki/Klasse_\(Programmierung\)), genau genommen deren [Schnittstellen](https://de.m.wikipedia.org/wiki/Schnittstelle_\(Programmierung\)), gelten als das Abbild eines abstrakten Datentyps. Hierbei ist aber eigentlich unpassend, dass bei Vererbung praktisch von keiner Sprache[[11]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) eine durchgangige Trennung der Vererbung von Schnittstelle und Implementierung explizit unterstutzt wird. Relativ neue Sprachen wie Java und .NET-Sprachen fuhren zwar mit den Schnittstellen _(Interfaces)_ ein Konzept zur Abbildung [abstrakter Datentypen](https://de.m.wikipedia.org/wiki/Abstrakter_Datentyp) ein, unterstutzen aber keine durchgangige Trennung, denn ist eine Schnittstelle einmal von einer Klasse implementiert, erbt jede weitere Spezialisierung sowohl die Implementierung als auch die Schnittstelle.[[3]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Spezialisten fur die objektorientierte Programmierung, beispielsweise [Bertrand Meyer](https://de.m.wikipedia.org/wiki/Bertrand_Meyer), sehen in einer vollstandigen Aufspaltung mehr Schaden als Nutzen.[[4]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Ein Grund ist, dass die Nahe von Schnittstelle und Implementierung im [Programmcode](https://de.m.wikipedia.org/wiki/Quelltext) das Verstandnis und die [Wartbarkeit](https://de.m.wikipedia.org/wiki/Softwarewartung) erleichtert.[[12]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

In diesem Zusammenhang von Bedeutung ist auch das [liskovsche Substitutionsprinzip](https://de.m.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip). Dieses fordert, dass ein Subtyp sich so verhalten muss, dass jemand, der meint, ein Objekt des Basistyps vor sich zu haben, nicht durch unerwartetes Verhalten uberrascht wird, wenn es sich dabei tatsachlich um ein Objekt des Subtyps handelt. Objektorientierte Programmiersprachen konnen eine Verletzung dieses Prinzips, das auf Grund der mit der Vererbung verbundenen [Polymorphie](https://de.m.wikipedia.org/wiki/Polymorphie_\(Programmierung\)) auftreten kann, nicht von vornherein ausschließen. Haufig ist eine Verletzung des Prinzips nicht auf den ersten Blick offensichtlich.[[9]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Wenn etwa beim oben skizzierten Beispiel in der Basisklasse `Rechteck` zur nachtraglichen Veranderung der Große die Methoden `setLaenge` und `setBreite` eingefuhrt werden[[A 3]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)), muss in der Klasse `Quadrat` entschieden werden, wie damit umzugehen ist. Eine mogliche Losung ist, dass beim Setzen der Lange automatisch die Breite auf denselben Wert gesetzt wird und umgekehrt. Wenn eine Anwendung unterstellt, ein Rechteck vor sich zu haben, und bei Verdopplung der Lange eines Rechtecks eine Verdopplung der Flache erwartet, uberrascht bei einer Instanz des Typs `Quadrat` die durch automatische Angleichung der Breite verursachte Vervierfachung der Flache.[[A 4]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Die fehlende Trennung zwischen Typ- und Implementierungsvererbung fuhrt in der Praxis haufig dazu, dass in der Schnittstelle einer Klasse Implementierungsdetails durchscheinen.[[13]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Eine Strategie zur Vermeidung dieses Effekts ist die Verwendung [abstrakter Klassen](https://de.m.wikipedia.org/wiki/Abstrakte_Klasse) oder Schnittstellen in den wurzelnahen Bereichen der Klassenhierarchie. Gunstig ist, auf abstrakter Ebene moglichst weit zu differenzieren, bevor Implementierungen erganzt werden. Eine solche auf Schnittstellen basierte Grundlage ist auch in Verbindung mit [verteilten Architekturen](https://de.m.wikipedia.org/wiki/Verteilte_Anwendung) wie [CORBA](https://de.m.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture) oder [COM](https://de.m.wikipedia.org/wiki/Component_Object_Model) notwendig.[[12]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Bei der reinen Implementierungsvererbung, die auch als _private Vererbung_ bezeichnet wird, nutzt die erbende Klasse die Funktionalitat und Attribute der Basisklasse, ohne nach außen als Unterklasse dieser Klasse zu gelten. Als - etwas konstruiertes - Beispiel konnte eine Klasse `RechtwinkligesDreieck` von der Klasse `Rechteck` des obigen Beispiels die Implementierung erben, um die [Hypotenuse](https://de.m.wikipedia.org/wiki/Hypotenuse) uber die Methode `getDiagonale` zu berechnen, nachdem die Lange der [Katheten](https://de.m.wikipedia.org/wiki/Kathete) fur Lange und Breite eingesetzt wurden.

Beispielsweise in C++ oder [Eiffel](https://de.m.wikipedia.org/wiki/Eiffel_\(Programmiersprache\)) gibt es die Moglichkeit einer reinen Implementierungsvererbung, in Java oder den .NET-Sprachen gibt es sie nicht. Eine Alternative bei letzteren Sprachen ist die Verwendung von [Delegation](https://de.m.wikipedia.org/wiki/Delegation_\(Softwareentwicklung\)), die einiges mehr Programmcode erfordert.[[9]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Wenn in einer Klasse eine [Methode](https://de.m.wikipedia.org/wiki/Methode_\(Programmierung\)) u[berschrieben](https://de.m.wikipedia.org/wiki/%C3%9Cberschreiben_\(OOP\)) wird, soll haufig nur Funktionalitat erganzt und die Implementierung der Basisklasse weiterhin genutzt werden, da diese bereits allgemeine Aspekte abdeckt, die fur die Spezialisierung ebenfalls gultig sind. Hierfur ist es erforderlich, dass innerhalb der Methodenimplementierung der spezialisierten Klasse das Pendant der Basisklasse aufgerufen wird. Dieser Aufruf erfolgt typischerweise zu Beginn oder am Ende der uberschreibenden Methode, teilweise ist aber auch zusatzliche Funktionalitat vor und nach diesem Aufruf zu implementieren.[[14]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

![](http://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/InheritancePgmCallHierarchie.png/350px-InheritancePgmCallHierarchie.png)

> _Beispiel einer Aufrufkaskade_

Die verschiedenen [Programmiersprachen](https://de.m.wikipedia.org/wiki/Programmiersprache) ermoglichen einen Aufruf der Basisklassenimplementierung auf unterschiedliche Weise. Die meisten Freiheitsgrade bietet C++, dort wird dem Methodennamen der Klassenname als Prafix vorangestellt _(Scope-Operator)_. Dieses Verfahren geht uber diesen Anwendungsfall weit hinaus, denn es ermoglicht den Aufruf jeder beliebigen Methode aller Klassen innerhalb der Klassenhierarchie. Etwas einschrankender ist beispielsweise Java, dort gibt es das Schlusselwort `super`, das dem Methodennamen vorangestellt wird. Deutlich formaler ist der Aufruf der Basisklassenmethode beispielsweise in der Sprache [CLOS](https://de.m.wikipedia.org/wiki/Common_Lisp_Object_System) gelost: Dort wird allein durch das Schlusselwort `call-next-method` die Basisimplementierung aufgerufen, ohne dass Methodenname oder [Parameter](https://de.m.wikipedia.org/wiki/Parameter_\(Informatik\)) spezifiziert werden, die aktuellen Parameter der spezialisierenden Methode werden implizit ubergeben. Der formalere Ansatz ist weniger redundant und fehleranfallig, bietet dafur aber weniger Flexibilitat.[[14]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Anhand des einfuhrenden Beispiels lasst sich eine solche Aufrufkaskade erlautern. Die Methode `PruefeFahrerlaubnis` gibt dabei zuruck, ob die Prufung durchgefuhrt werden konnte, und wenn dies der Fall ist, zusatzlich das Ergebnis dieser Prufung. Die Implementierung der Klasse `PKW` ruft zunachst die Implementierung der Klasse `Kraftfahrzeug` auf, um die Falle abzuhandeln, die anhand Hochstgeschwindigkeit, Leistung oder zulassigem Gesamtgewicht entscheidbar sind. Die Implementierung in `Kraftfahrzeug` wiederum delegiert die Prufung des zulassigen Gesamtgewichts weiter an seine Basisklasse. Nach Rucksprung aus den gerufenen Basisimplementierungen wird die Prufung jeweils fortgesetzt, wenn der Fall noch nicht entschieden werden konnte.

-> _Hauptartikel: [Mehrfachvererbung](https://de.m.wikipedia.org/wiki/Mehrfachvererbung)_

![](http://upload.wikimedia.org/wikipedia/commons/thumb/2/20/InheritancePgmExampleMI.svg/370px-InheritancePgmExampleMI.svg.png)

> _Mehrfachvererbung mit gemeinsamer indirekter Basisklasse (_

Um Mehrfachvererbung handelt es sich, wenn eine abgeleitete Klasse direkt von mehr als einer Basisklasse erbt. Ein sequentielles, mehrstufiges Erben wird dagegen nicht als Mehrfachvererbung bezeichnet. Ein sehr haufiger Anwendungsfall der Mehrfachvererbung ist die Verwendung von [Mixin-Klassen](https://de.m.wikipedia.org/wiki/Mixin-Klasse), die allgemein verwendbare Implementierungen beisteuern und somit der Vermeidung von [Redundanz](https://de.m.wikipedia.org/w/index.php?title=Redundanz_\(Quelltext\)&action=edit&redlink=1) dienen.[[15]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

![](http://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Two-way-vehicle_unimog.jpg/220px-Two-way-vehicle_unimog.jpg)

> _Zweiwegefahrzeug (Unimog)_

Ein anderes Beispiel fur Mehrfachvererbung ergibt sich durch die Erweiterung des einfuhrenden Beispiels um die Klassen `[Schienenfahrzeug](https://de.m.wikipedia.org/wiki/Schienenfahrzeug)` und `[Zweiwegefahrzeug](https://de.m.wikipedia.org/wiki/Zweiwegefahrzeug)`. Letztere erbt dabei sowohl von `Kraftfahrzeug` als auch von `Schienenfahrzeug` und hat somit sowohl alle Attribute der Kraftfahrzeuge als auch das zusatzliche Attribut `Spurweite`, das von `Schienenfahrzeug` geerbt wird.

Die Notwendigkeit von Mehrfachvererbung ist umstritten, sie wird nicht von allen Sprachen unterstutzt, beispielsweise nicht von [Smalltalk](https://de.m.wikipedia.org/wiki/Smalltalk_\(Programmiersprache\)). Die erste Sprache, die eine Mehrfachvererbung unterstutzte, war [Flavors](https://de.m.wikipedia.org/wiki/Flavors_\(Programmiersprache\)), eine objektorientierte Erweiterung von [LISP](https://de.m.wikipedia.org/wiki/LISP). Eine umfassende Unterstutzung bieten beispielsweise auch [C++](https://de.m.wikipedia.org/wiki/C%2B%2B), [Eiffel](https://de.m.wikipedia.org/wiki/Eiffel_\(Programmiersprache\)) und [Python](https://de.m.wikipedia.org/wiki/Python_\(Programmiersprache\)). [Java](https://de.m.wikipedia.org/wiki/Java_\(Programmiersprache\)) und [.NET-Sprachen](https://de.m.wikipedia.org/wiki/Liste_von_.NET-Sprachen) bieten eine eingeschrankte Unterstutzung, dort kann eine Klasse zwar von beliebig vielen [Schnittstellen](https://de.m.wikipedia.org/wiki/Schnittstelle_\(Programmierung\)), aber nur von einer Klasse erben, die Implementierungen enthalt.[[15]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Eine andere Losung halt [Ruby](https://de.m.wikipedia.org/wiki/Ruby_\(Programmiersprache\)) bereit, dort ist ebenfalls nur eine direkte Basisklasse moglich, allerdings kann eine Klasse beliebig viele sogenannte _Modules_ einbinden, was dem Grundgedanken einer [Mixin](https://de.m.wikipedia.org/wiki/Mixin)-Vererbung direkt entspricht.[[16]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Neben einem erheblichen zusatzlichen Implementierungsaufwand fur [Compiler](https://de.m.wikipedia.org/wiki/Compiler) und [Laufzeitumgebung](https://de.m.wikipedia.org/wiki/Laufzeitumgebung) gibt es vor allem zwei Grunde fur die haufige fehlende oder eingeschrankte Unterstutzung:[[17]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

  1. Mogliche Namenskollisionen bei geerbten Attributen oder Methoden
  2. Mehrfaches Auftreten derselben Basisklasse im Vererbungsbaum

Fur erstgenanntes Problem bieten die Sprachen meist Moglichkeiten der Umbenennung. Letztere Konstellation, die auch als [Diamond-Problem](https://de.m.wikipedia.org/wiki/Diamond-Problem) bezeichnet wird, tritt nur bei Vererbung der Implementierung in Erscheinung. Hier kann es sowohl sinnvoll sein, dass das resultierende Objekt nur eine Instanz der mehrfach auftretenden Klasse enthalt, als auch mehrere. Fur das obige Beispiel des Zweiwegefahrzeugs bedeutet dies entweder das Vorhandensein von nur einer Instanz der Basisklasse `Fahrzeug` oder von deren zwei. C++ bietet uber das Konzept sogenannter _virtueller Basisklassen_ beide Moglichkeiten an.[[17]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Eiffel bietet auch beide Moglichkeiten und dies sogar auf Ebene einzelner Attribute und Methoden.[[18]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Das kann im skizzierten Beispiel sogar sinnvoll sein: Das Leergewicht ist bei einem Zweiwegefahrzeug grundsatzlich gleich, egal ob es auf der Schiene oder auf der Straße betrieben wird. Dies muss aber nicht unbedingt auch fur das zulassige Gesamtgewicht gelten. Python hat zum Erzeugen einer sinnvollen Vererbungshierarchie seit Version 2.3 in solchen Fallen das Konzept der sogenannten _C3-Linearisierung_ implementiert.

Im Zusammenhang mit dem [liskovschen Substitutionsprinzip](https://de.m.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip) steht auch die Behandlung der Varianz bei den [Signaturen](https://de.m.wikipedia.org/wiki/Signatur_\(Programmierung\)) uberschriebener [Methoden](https://de.m.wikipedia.org/wiki/Methode_\(Programmierung\)). Viele Programmiersprachen ermoglichen keine Varianz, das heißt, die Typen der [Methodenparameter](https://de.m.wikipedia.org/wiki/Parameter_\(Informatik\)) uberschriebener Methoden mussen exakt ubereinstimmen. Dem liskovschen Prinzip entspricht die Unterstutzung von Kontravarianz fur Eingangs- und Kovarianz fur Ausgangsparameter. Das bedeutet, Eingangsparameter konnen allgemeiner sein als bei der Basisklasse, der Typ des Ruckgabewerts darf spezieller sein.[[19]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Von wenigen Sprachen wird die Deklaration der [Ausnahmen](https://de.m.wikipedia.org/wiki/Ausnahmebehandlung) (engl. _Exceptions_) ermoglicht, die beim Aufruf einer Methode auftreten konnen. Die Typen der moglichen Ausnahmen gehoren dabei zur Signatur einer Methode. Bei Java und [Modula-3](https://de.m.wikipedia.org/wiki/Modula-3) - den beiden einzigen bekannteren Sprachen, die so etwas unterstutzen - muss die Menge der moglichen Ausnahmetypen einer uberschriebenen Methode eine [Teilmenge](https://de.m.wikipedia.org/wiki/Teilmenge) der ursprunglichen Typen sein, was Kovarianz bedeutet und dem liskovschen Substitutionsprinzip entspricht.[[20]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))[[A 5]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Im Zusammenhang mit dem liskovschen Substitutionsprinzip steht auch das [Design-By-Contract](https://de.m.wikipedia.org/wiki/Design_by_contract)-Konzept, das von [Eiffel](https://de.m.wikipedia.org/wiki/Eiffel_\(Programmiersprache\)) unterstutzt wird. Dabei gibt es die Moglichkeit, [Vor](https://de.m.wikipedia.org/wiki/Vorbedingung_\(Informatik\))\- und [Nachbedingungen](https://de.m.wikipedia.org/wiki/Nachbedingung_\(Informatik\)) fur Methoden sowie [Invarianten](https://de.m.wikipedia.org/wiki/Invariante_\(Informatik\)) fur Klassen zu definieren. Die Klassenvarianten sowie die Nachbedingungen mussen dabei in Spezialisierungen gleich oder restriktiver sein, die Vorbedingungen konnen gelockert werden.[[21]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Bei der Spezifizierung der Sichtbarkeit der Attribute und Methoden von Klassen ([Datenkapselung](https://de.m.wikipedia.org/wiki/Datenkapselung_\(Programmierung\))) wird haufig unterschieden, ob der Zugriff beispielsweise durch eine abgeleitete Klasse oder „von außen", das heißt bei einer anderweitigen Verwendung der Klasse, erfolgt. In den meisten Sprachen werden drei Falle unterschieden:[[22]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

  * offentlich _(public)_: Die Eigenschaft ist ohne Einschrankungen sichtbar
  * geschutzt _(protected)_: Die Eigenschaft ist in der Klasse selbst und fur abgeleitete Klassen sichtbar (auch mehrstufig), von außen hingegen nicht.
  * privat _(private)_: Die Eigenschaft ist nur in der Klasse selbst sichtbar.

Nicht alle Sprachen unterstutzen diese dreiteilige Gliederung. Manche Abgrenzungen der Sichtbarkeit sind auch anders ausgelegt. Java und die .NET-Sprachen fuhren zusatzlich noch Varianten ein, die die Sichtbarkeit auf sprachspezifische Untereinheiten der Programmstruktur (Package oder [Assembly](https://de.m.wikipedia.org/wiki/.NET)) begrenzen. In [Ruby](https://de.m.wikipedia.org/wiki/Ruby_\(Programmiersprache\)) hat _`private`_ eine abweichende Bedeutung: Auf private Eigenschaften kann auch von spezialisierenden Klassen zugegriffen werden. Allerdings ist grundsatzlich nur der Zugriff auf Eigenschaften derselben Instanz moglich.[[23]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))[[A 6]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Ein weiterer, bei Vererbung relevanter Aspekt der Datenkapselung ist die Moglichkeit, in abgeleiteten Klassen die Sichtbarkeit von Eigenschaften gegenuber der Basisklasse zu verandern. Beispielsweise in C++ oder Eiffel ist es moglich, die Sichtbarkeit aller oder einzelner Eigenschaften beim Erben einzuschranken. In Java oder den .NET-Sprachen dagegen ist keine solche Änderung der Sichtbarkeit bei Vererbung moglich.[[22]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Programmiersprachen lassen sich in solche mit [statischer](https://de.m.wikipedia.org/wiki/Statische_Typisierung) oder [dynamischer Typisierung](https://de.m.wikipedia.org/wiki/Dynamische_Typisierung) einteilen. Bei dynamischer Typisierung wird fur [Variablen](https://de.m.wikipedia.org/wiki/Variable_\(Programmierung\)) und [Parameter](https://de.m.wikipedia.org/wiki/Parameter_\(Informatik\)) nicht explizit ein Typ festgelegt. [Smalltalk](https://de.m.wikipedia.org/wiki/Smalltalk_\(Programmiersprache\)) war die erste objektorientierte Sprache mit dynamischer Typisierung. Bei statischer Typisierung dagegen wird - meist durch eine [Deklaration](https://de.m.wikipedia.org/wiki/Deklaration_\(Programmierung\)) wie beispielsweise in Java - kenntlich gemacht, welchen Typ der Wert einer Variablen oder eines Parameters aufweisen muss. Bei [Zuweisung](https://de.m.wikipedia.org/wiki/Zuweisung) oder [Parameterubergabe](https://de.m.wikipedia.org/wiki/Parameter%C3%BCbergabe) kann die [Zuweisungskompatibilitat](https://de.m.wikipedia.org/wiki/Zuweisungskompatibilit%C3%A4t) der Typen in diesem Fall bereits wahrend der Ü[bersetzungszeit](https://de.m.wikipedia.org/wiki/%C3%9Cbersetzungszeit) gepruft werden.[[24]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

An jeder Stelle, an der ein Objekt einer bestimmten Klasse erwartet wird, kann auch ein Objekt verwendet werden, das einer Spezialisierung dieser Klasse angehort. Beispielsweise kann eine Variable des Typs `PKW` immer einer Variable des Typs `Kraftfahrzeug` zugewiesen werden. Allerdings sind nach einer solchen Zuweisung die zusatzlichen Eigenschaften der Spezialisierung, im Beispiel die Anzahl der Sitzplatze, nicht direkt zuganglich. Das Objekt der Basisklasse verhalt sich jedoch beim Aufruf von virtuellen Methoden wie ein Objekt der spezialisierenden Klasse.[[A 7]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Eine solche [Konvertierung](https://de.m.wikipedia.org/wiki/Typumwandlung) wird _Upcast_ genannt.[[25]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Das Gegenstuck dazu, ein _Downcast_, ist problematischer, jedoch in einigen Fallen notwendig. Auch statisch typisierende Sprachen ermoglichen meist eine solche Konvertierung, die aber explizit veranlasst werden muss. In diesem Fall ist auch bei statisch typisierenden Sprachen erst zur [Laufzeit](https://de.m.wikipedia.org/wiki/Laufzeit_\(Informatik\)) uberprufbar, ob ein Objekt tatsachlich den geforderten Typ aufweist.[[9]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Ein solcher Downcast, beispielsweise von `Kraftfahrzeug` zu `PKW`, ist nur sinnvoll, wenn sichergestellt ist, dass das Objekt tatsachlich vom Typ der konkreten Spezialisierung ist. Wird keine Prufung durchgefuhrt und in diesem Beispiel ein Objekt, das einen LKW reprasentiert, in den Typ `PKW` konvertiert, wird im Regelfall eine [Ausnahme](https://de.m.wikipedia.org/wiki/Ausnahmebehandlung) erzeugt.

Viele [objektorientierte Programmiersprachen](https://de.m.wikipedia.org/wiki/Objektorientierte_Programmiersprache) verfugen uber eine zentrale Klasse, von der alle Klassen - uber wie viele Stufen auch immer - letztlich abgeleitet sind. Beispielsweise gibt es in Ruby, Java und bei .NET eine solche Klasse. Diese heißt bei diesen Sprachen `Object`. In Eiffel wird sie mit `ANY` bezeichnet. Zu den wenigen Ausnahmen, in denen es keine solche Klasse gibt, zahlen C++ oder Python.

In den Sprachen mit zentraler Basisklasse erbt eine Klasse, fur die keine Basisklasse angegeben wird, implizit von dieser besonderen Klasse. Ein Vorteil davon ist, dass allgemeine Funktionalitat, beispielsweise fur die [Serialisierung](https://de.m.wikipedia.org/wiki/Serialisierung) oder die [Typinformation](https://de.m.wikipedia.org/wiki/Runtime_Type_Information), dort untergebracht werden kann. Weiterhin ermoglicht es die Deklaration von [Variablen](https://de.m.wikipedia.org/wiki/Variable_\(Programmierung\)), denen ein Objekt jeder beliebigen Klasse zugewiesen werden kann. Dies ist besonders hilfreich zur Implementierung von [Containerklassen](https://de.m.wikipedia.org/wiki/Container_\(Informatik\)), wenn eine Sprache keine [generische Programmierung](https://de.m.wikipedia.org/wiki/Generische_Programmierung) unterstutzt.[[A 8]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Dieses Verfahren hat allerdings den Nachteil, dass in einen solchen allgemeinen Container Objekte jeden Typs hinzugefugt werden konnen. Da beim Zugriff auf ein Objekt des Containers normalerweise ein spezieller Typ erwartet wird, ist deshalb eine [Typumwandlung](https://de.m.wikipedia.org/wiki/Typumwandlung) _(Downcast)_ erforderlich. Die entsprechende [Typprufung](https://de.m.wikipedia.org/wiki/Typsicherheit) kann jedoch erst zur Laufzeit erfolgen.[[26]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Neben einer einfachen [Serialisierung](https://de.m.wikipedia.org/wiki/Serialisierung) ist die Speicherung in einer [Datenbank](https://de.m.wikipedia.org/wiki/Datenbank) das ublichste Verfahren, Objekte [persistent](https://de.m.wikipedia.org/wiki/Persistenz_\(Informatik\)) zu machen. [Objektorientierte Datenbanken](https://de.m.wikipedia.org/wiki/Objektorientierte_Datenbank) haben das Ziel, einen sogenannten _[Impedance Mismatch](https://de.m.wikipedia.org/wiki/Impedance_Mismatch)_ zu vermeiden, der bei Abbildung der bei der Programmierung verwendeten Vererbungs- und Objektstruktur auf eine [relationale Datenbank](https://de.m.wikipedia.org/wiki/Relationale_Datenbank) entsteht. Objektorientierte Datenbanken haben sich aber bis heute nicht durchgesetzt, so dass haufig sogenannte [objektrelationale Mapper](https://de.m.wikipedia.org/wiki/Objektrelationale_Abbildung) verwendet werden.[[27]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Bei der objektrelationalen Abbildung der Vererbungsbeziehungen werden drei Moglichkeiten unterschieden:[[28]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

  1. Die Attribute aller Klassen einer Hierarchie werden in einer Tabelle gespeichert _(Single Table Inheritance)_
  2. Die Attribute jeder Klasse werden in einer separaten Tabelle gespeichert _(Class Table Inheritance)_
  3. Die Attribute jeder nicht [abstrakten Klasse](https://de.m.wikipedia.org/wiki/Abstrakte_Klasse) werden in einer separaten Tabelle gespeichert _(Concrete Table Inheritance)_

Bei der ersten Variante _(Single Table Inheritance)_ muss der Typ des Objekts in einer zusatzlichen [Spalte](https://de.m.wikipedia.org/w/index.php?title=Spalte_\(Datenbank\)&action=edit&redlink=1) gespeichert werden. Die Spalten der Attribute, die bei konkreten Objekten der Klassenhierarchie nicht vorhanden sind, enthalten [Null-Werte](https://de.m.wikipedia.org/wiki/Nullwert). Beides ist bei den zwei letzten Varianten nicht notig, die dritte Variante ist dabei eine Art Kompromiss.[[28]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Bei echten objektorientierten Datenbanken werden im Wesentlichen zwei gegensatzliche Strategien unterschieden: Persistenz durch Vererbung _(by Inheritance)_ und orthogonale Persistenz. Bei der Persistenz durch Vererbung hangt die Eigenschaft, ob ein Objekt transient oder persistent ist, vom Typ ab, und wird durch Erben von einer Klasse etabliert, die die Funktionalitat zur Anbindung an die Datenbank bereitstellt. Bei orthogonaler Persistenz konnen Objekte derselben Klasse sowohl persistent als auch transient sein, die Eigenschaft ist also vollig unabhangig vom Typ.[[29]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Objektorientierte Elemente und dabei nicht zuletzt der Vererbungsmechanismus besitzen eine Ausdrucksstarke, die sich sehr positiv auf die Qualitat und Verstandlichkeit eines Systementwurfs auswirkt. Umfangreiche [Klassenbibliotheken](https://de.m.wikipedia.org/wiki/Klassenbibliothek) sind entstanden, deren Funktionalitat mit Hilfe der Vererbung anwendungsspezifisch angepasst oder erweitert werden kann. Nicht zuletzt dank des Vererbungsmechanismus konnen Softwaresysteme [modular](https://de.m.wikipedia.org/wiki/Modul_\(Software\)) aufgebaut werden, was die Beherrschbarkeit großer Systeme ermoglicht und beispielsweise auch [Portierungen](https://de.m.wikipedia.org/wiki/Migration_\(Informationstechnik\)) erleichtert.[[30]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) Allerdings steigern unnotig tief verschachtelte Vererbungshierarchien die Komplexitat und das Verstandnis erheblich, was zu Fehlern bei Verwendung oder Änderung der Basisklassen fuhren kann.[[31]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Neben den positiven Aspekten haben sich bei der objektorientierten Programmierung auch negative Aspekte im Hinblick auf die [Softwarewartung](https://de.m.wikipedia.org/wiki/Softwarewartung) gezeigt, die vor allem im Zusammenhang mit der [Polymorphie](https://de.m.wikipedia.org/wiki/Polymorphie_\(Programmierung\)), aber auch mit der Vererbung stehen.[[32]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Der wohl problematischste Fall ist die nachtragliche Änderung der Schnittstelle einer zentralen Klasse, von der es zahlreiche Spezialisierungen gibt, beispielsweise im Zusammenhang mit der Umstellung auf eine neue Version einer Klassenbibliothek. Hierbei sind vor allem zwei Falle zu unterscheiden:[[30]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

  1. Anpassung der [Signatur](https://de.m.wikipedia.org/wiki/Signatur_\(Programmierung\)) einer bestehenden virtuellen Methode oder deren Umbenennung

Falls im ersten Fall die neue Methode ohne Implementierung eingefuhrt wird, als Bestandteil einer [abstrakten Klasse](https://de.m.wikipedia.org/wiki/Abstrakte_Klasse), mussen alle Spezialisierungen bei Versionsumstieg nun diese Funktionalitat bereitstellen. Weit schwerwiegender ist allerdings, wenn in der Vererbungshierarchie in nachgeordneten Klassen bereits eine gleichnamige virtuelle Methode existierte. Dieser Fall kann in den meisten Sprachen nicht vom [Compiler](https://de.m.wikipedia.org/wiki/Compiler) aufgedeckt werden. Diese bestehende virtuelle Methode wird nun in einem Kontext aufgerufen, fur den sie nicht implementiert wurde. Wird dieses Problem nicht anhand der Bearbeitung der Dokumentation des Versionswechsels beseitigt, fuhrt es zu inkorrektem Systemverhalten und meist zu einem [Laufzeitfehler](https://de.m.wikipedia.org/wiki/Laufzeitfehler).[[30]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Im zweiten Fall muss die Umbenennung oder Signaturanpassung in den spezialisierenden Klassen nachgezogen werden. Erfolgt dies nicht, hangen die bisherigen Implementierungen nun „in der Luft", das heißt, sie werden an erforderlichen Stellen nicht mehr aufgerufen, stattdessen wird eine in einer Basisklasse existierende Standardfunktionalitat verwendet, die eigentlich vorgesehene angepasste Funktionalitat kommt nicht mehr zur Ausfuhrung. Auch dieses Problem kann in einigen Konstellationen nicht vom Compiler aufgedeckt werden.[[30]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Die Sicherstellung, dass solche Probleme vom Compiler erkannt werden konnen, erfordert eigentlich eine vergleichsweise geringfugige Erganzung einer Sprache. Bei [C#](https://de.m.wikipedia.org/wiki/C-Sharp) beispielsweise ist dies durch das Schlusselwort `override` abgedeckt. Bei allen Methoden, die eine virtuelle Methode der Basisklasse uberschreiben, muss dieses Schlusselwort angegeben werden. Dass in den meisten Sprachen wie auch C++ oder Java[[A 9]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\)) eine derartige Unterstutzung fehlt, liegt daran, dass dieser Aspekt bei Konzeption der Sprache keine ausreichende Berucksichtigung fand, und die nachtragliche Einfuhrung eines solchen [Schlusselworts](https://de.m.wikipedia.org/wiki/Schl%C3%BCsselwort_\(Programmierung\)) aufgrund großer [Kompatibilitatsprobleme](https://de.m.wikipedia.org/wiki/Kompatibilit%C3%A4t_\(Technik\)) auf erheblichen Widerstand stoßt.[[30]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

-> _Hauptartikel: [Fragile Base Class Problem](https://de.m.wikipedia.org/wiki/Fragile_Base_Class_Problem)_

Auch ohne die Änderung einer Klassenschnittstelle kann es bei Umstellung auf eine neue Version einer Basisklasse zu Problemen kommen. Die Entwickler, die eine „zerbrechliche" Basisklasse andern, sind in diesem Fall nicht in der Lage, die negativen Konsequenzen vorauszuahnen, die sich fur spezialisierte Klassen durch die Änderung ergeben. Die Grunde hierfur sind vielfaltig, im Wesentlichen liegt ein Missverstandnis zwischen den Entwicklern der Basisklasse und denen der verwendeten Spezialisierungen vor. Dies liegt zumeist daran, dass die Funktionalitat der Basisklasse und auch das von den Spezialisierungen erwartete Verhalten nicht ausreichend prazise spezifiziert sind.[[33]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))[[34]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Eine haufige Ursache des Fragile Base Class Problems ist die zu großzugige Offenlegung von Implementierungsdetails, die zumeist aus praktischen Grunden erfolgt, wobei auch Teile offengelegt werden, die in einer anfanglichen Version noch nicht ausgereift sind. Die Programmiersprachen erleichtern die Umsetzung sinnvoller Einschrankungen der Freiheitsgrade haufig nicht, beispielsweise sind in Java Methoden grundsatzlich virtuell und mussen als `final` gekennzeichnet werden, wenn kein Ü[berschreiben](https://de.m.wikipedia.org/wiki/%C3%9Cberschreiben_\(OOP\)) durch eine ableitende Klasse moglich sein soll.[[35]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

Der Begriff Vererbung wird auch bei [prototypenbasierten Programmierung](https://de.m.wikipedia.org/wiki/Prototypenbasierte_Programmierung) verwendet. Bei prototypenbasierten Sprachen wird aber nicht zwischen [Klasse](https://de.m.wikipedia.org/wiki/Klasse_\(Programmierung\)) und instantiiertem [Objekt](https://de.m.wikipedia.org/wiki/Objekt_\(Programmierung\)) unterschieden. Dementsprechend ist hier mit Vererbung nicht ganz dasselbe gemeint, denn ein durch [Cloning](https://de.m.wikipedia.org/w/index.php?title=Cloning_\(Programmierung\)&action=edit&redlink=1) erzeugtes neues Objekt „erbt" nicht nur die Struktur des auch als _Parent_ bezeichneten Originals, sondern auch die Inhalte. Der Mechanismus zur Nutzung der Methoden des _Parent_ durch die Kopie _(Child)_ entspricht eigentlich einer [Delegation](https://de.m.wikipedia.org/wiki/Delegation_\(Softwareentwicklung\)). Diese ist im Sinne einer Vererbung verwendbar, hat aber mehr Freiheitsgrade, beispielsweise ist bei einigen derartigen Sprachen der Adressat der Delegation - und damit die „Basisklasse" - zur Laufzeit austauschbar.[[36]](https://de.m.wikipedia.org/wiki/Vererbung_\(Programmierung\))

  * Bernhard Lahres, Gregor Rayman: _Praxisbuch Objektorientierung. Von den Grundlagen zur Umsetzung_. Galileo Press, Bonn 2006, [ISBN 3-89842-624-6](https://de.m.wikipedia.org/wiki/Spezial:ISBN-Suche/3898426246).
  * Klaus Zeppenfeld: _Objektorientierte Programmiersprachen. Einfuhrung und Vergleich von Java, C++, C#, Ruby_. Spektrum Akademischer Verlag, Munchen 2004, [ISBN 3-8274-1449-0](https://de.m.wikipedia.org/wiki/Spezial:ISBN-Suche/3827414490).
  1. ↑ Die Modellierung dient hier nur zur Veranschaulichung. Beispielsweise waren Attribute wie Antriebsart, Hubraum und ob ein Anhanger mitgefuhrt wird in einem realitatsnahen System ebenfalls zu berucksichtigen.
  2. ↑ Die Menge der moglichen Auspragungen des Subtyps bildet weiterhin eine Teilmenge des Basistyps, wenn lediglich die Attribute des Basistyps betrachtet werden.
  3. ↑ Eine solche Änderung kann in der Praxis durchaus nachtraglich erfolgen und ohne dass der Entwickler der Basisklasse und der abgeleiteten Klasse sich kennen mussen, beispielsweise bei Verwendung einer [Klassenbibliothek](https://de.m.wikipedia.org/wiki/Klassenbibliothek) und der Umstellung auf eine neue Version.
  4. ↑ Dieser Aspekt ist ein Grund dafur, warum eine derartige Spezialisierung in einigen Anwendungsfallen ungunstig ist. Dieses Beispiel wird haufig zur Veranschaulichung und Diskussion dieses in Verbindung mit der Vererbung stehenden Problems verwendet und ist auch unter der Bezeichnung [Kreis-Ellipse-Problem](https://de.m.wikipedia.org/wiki/Kreis-Ellipse-Problem) _(circle ellipse problem)_ bekannt.
  5. ↑ In Java gilt dieses Prinzip allerdings nur fur einen Teil der moglichen Ausnahmetypen, den sogenannten _Checked Exceptions_.
  6. ↑ Bei C++ oder Java ist dagegen der Zugriff auf private Eigenschaften anderer Instanzen derselben Klasse moglich, was typischerweise beim [Copy-Konstruktor](https://de.m.wikipedia.org/wiki/Kopierkonstruktor) durch direkten Zugriff auf die Eigenschaften des Quellobjekts ausgenutzt wird.
  7. ↑ In Java Version 1.5 wurde eine [Annotation](https://de.m.wikipedia.org/wiki/Annotation_\(Programmierung\)) `@Override` eingefuhrt, die das Problem aber nur teilweise lost, vor allem da man sie nicht benutzen muss.
