# Type Encodings

_Captured: 2016-03-06 at 21:54 from [developer.apple.com](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)_

[Next](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)[Previous](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html)

To assist the runtime system, the compiler encodes the return and argument types for each method in a character string and associates the string with the method selector. The coding scheme it uses is also useful in other contexts and so is made publicly available with the `@encode()` compiler directive. When given a type specification, `@encode()` returns a string encoding that type. The type can be a basic type such as an `int`, a pointer, a tagged structure or union, or a class name--any type, in fact, that can be used as an argument to the C `sizeof()` operator.
    
    
    char *buf1 = @encode(int **);
    
    
    char *buf2 = @encode(struct key);
    
    
    char *buf3 = @encode(Rectangle);

The table below lists the type codes. Note that many of them overlap with the codes you use when encoding an object for purposes of archiving or distribution. However, there are codes listed here that you can't use when writing a coder, and there are codes that you may want to use when writing a coder that aren't generated by `@encode()`. (See the `[NSCoder](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCoder_Class/index.html)` class specification in the Foundation Framework reference for more information on encoding objects for archiving or distribution.)

**Table 6-1** Objective-C type encodings

Code

Meaning

`c`

A `char`

`i`

An `int`

`s`

A `short`

`l`

A `long`

`l` is treated as a 32-bit quantity on 64-bit programs.

`q`

A `long long`

`C`

An `unsigned char`

`I`

An `unsigned int`

`S`

An `unsigned short`

`L`

An `unsigned long`

`Q`

An `unsigned long long`

`f`

A `float`

`d`

A `double`

`B`

A C++ `bool` or a C99 `_Bool`

`v`

A `void`

`*`

A character string (`char *`)

`@`

An object (whether statically typed or typed `id`)

`#`

A class object (`Class`)

`:`

A method selector (`SEL`)

[_array type_] 

An array

{_name=type..._}

A structure

(_name_=_type..._)

A union

`b`num

A bit field of _num_ bits

`^`type

A pointer to _type_

`?`

An unknown type (among other things, this code is used for function pointers)

**Important:** Objective-C does not support the `long double` type. `@encode(long double)` returns `d`, which is the same encoding as for `double`.

The type code for an array is enclosed within square brackets; the number of elements in the array is specified immediately after the open bracket, before the array type. For example, an array of 12 pointers to `float`s would be encoded as:
    
    
    [12^f]

Structures are specified within braces, and unions within parentheses. The structure tag is listed first, followed by an equal sign and the codes for the fields of the structure listed in sequence. For example, the structure
    
    
    typedef struct example {
    
    
        id   anObject;
    
    
        char *aString;
    
    
        int  anInt;
    
    
    } Example;

would be encoded like this:
    
    
    {example=@*i}

The same encoding results whether the defined type name (`Example`) or the structure tag (`example`) is passed to `@encode()`. The encoding for a structure pointer carries the same amount of information about the structure's fields:
    
    
    ^{example=@*i}

However, another level of indirection removes the internal type specification:
    
    
    ^^{example}

Objects are treated like structures. For example, passing the `NSObject` class name to `@encode()` yields this encoding:
    
    
    {NSObject=#}

The `NSObject` class declares just one instance variable, `isa`, of type Class.

Note that although the `@encode()` directive doesn't return them, the runtime system uses the additional encodings listed in Table 6-2 for type qualifiers when they're used to declare methods in a protocol.

**Table 6-2** Objective-C method encodings

Code

Meaning

`r`

`const`

`n`

`in`

`N`

`inout`

`o`

`out`

`O`

`bycopy`

`R`

`byref`

`V`

`oneway`

[Next](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)[Previous](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html)
