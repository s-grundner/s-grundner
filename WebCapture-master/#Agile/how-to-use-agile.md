# How to Use Agile

_Captured: 2017-03-13 at 11:27 from [shift.newco.co](https://shift.newco.co/how-to-use-agile-f1e1152f6fa6?source=userActivityShare-c79006fee040-1489400842)_

![](https://cdn-images-1.medium.com/max/800/1*7GDjRpP-g2nUMrwXe5Guhw.png)

Agile began as a way to develop software, but now refers more generally, to _nimble_ methods of product development.

Now that Agile has escaped from the world of software development, how best can its methods be applied?

**What is Agile?**

The essence of Agile is _iteration_:

  * Working through a _list_ of relatively _short tasks_.
  * In order of _priority_ -- set partly by customer need and partly by engineering efficiency.
  * _Easily_ adding new tasks and changing priorities -- as new information and requirements emerge.
  * Making _regular _demonstrations to the customer -- to seek their feedback and apply it.

**Iterations**

Agile works best when _rapid iteration_ is possible.

  * When new features can be added_ quickly_ and demonstrated_ easily_.
  * When customer feedback is _readily_ available.
  * When rapid change is _easy_ to accomplish.

So think about _what iteration looks like_ for each of your development tasks, and then choose a method that's _appropriate_ for each.

**Demonstrations**

To get the feedback needed to direct rapid iteration, you need _regular_ and _easy_ customer demonstrations.

  * For software development this means establishing _Continuous Integration_ -- infrastructure to build and test every night, ready to demonstrate the next day.
  * For hardware development it can be difficult to make regular demonstrations of new features, but _rapid prototyping_ techniques can help.

Remember that you also need a customer who can see your demonstrations and then give you _rapid_ and _definitive_ feedback.

**Completion**

Agile works thought a list of tasks, which -- by design -- is easy to change. So it can be hard to predict when work will be complete and even what complete will look like.

This can be acceptable when functionality can flex, but less so when you need to commit to specific deliverables.

Traditional methods of project planning may _appear_ to give a more reliable completion date, but the planning is often deceptive.

Either way, a good understanding of uncertainty -- and its communication to the customer -- is the key.

**Mix and Match**

For most development projects, there are aspects that lend themselves to Agile and others that do not.

So a _mix_ of methods usually works best -- picking the best method for each task -- using Agile to manage software tasks within a more traditionally planned backbone for example.

**Points to take away â€¦**

  * **Think about what iteration looks like before deciding whether Agile is right.**
  * **Make sure you can demonstrate regularly and easily -- and that you have a customer who can feedback.**
  * **Mix and match -- choose the most appropriate development method for each task.**
