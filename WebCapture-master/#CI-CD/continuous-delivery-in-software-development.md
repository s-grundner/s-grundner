# Continuous Delivery in Software Development

_Captured: 2018-05-04 at 17:20 from [dzone.com](https://dzone.com/articles/continuous-delivery-in-software-development?edition=376246&utm_source=Zone%20Newsletter&utm_medium=email&utm_campaign=devops%202018-05-04)_

With the influx of DevOps-related products and services on the market, today's application delivery toolchain has become complex and fragmented. Watch [Avoiding the DevOps Tax](https://dzone.com/go?i=286421&u=https%3A%2F%2Fabout.gitlab.com%2F2018%2F03%2F21%2Favoiding-devops-tax-webcast%2F) to learn best practices for integration and automation to realize a faster DevOps lifecycle.

Continuous Delivery (CD) is the next step in the evolution of the software development process. It draws on Agile methodologies but surpasses it. CD is changing the way software is delivered and opening up a whole range of benefits, ranging from greater adaptability to more reliable products to improved customer experiences.

But what if CD means sacrificing quality for speed? Does it really CD lead to both higher responsiveness and higher reliability? Let's find out if it really enables you to get better products to your customers more often.

## What Is It?

Continuous Delivery is a methodology that focuses on smaller releases more often to avoid the issues and bugs that come with large, slow releases. CD can actually make your software development more agile and more able to react to changes. CD comes with quicker reaction times, less risk and more flexible release options. It also identifies inefficiencies and hidden costs.

Considering the rapid pace of technological innovation, and consumers' rising expectations for quality products, it makes sense to evaluate and modernize software delivery processes to keep pace with these developments.

## Why Continuous Delivery?

The practices at the heart of continuous delivery help us achieve several important benefits:

  * **Lower Costs: **Any successful software product or service will evolve significantly over the course of its lifetime. By investing in build, test, deployment and environment automation, we substantially reduce the cost of making and delivering incremental changes to software by eliminating many of the fixed costs associated with the release process.

  * **Low-Risk Releases: **The primary goal of continuous delivery is to make software deployments painless, low-risk events that can be performed at any time, on demand. By applying patterns such as blue-green deployments it is relatively straightforward to achieve zero-downtime deployments that are undetectable to users.

  * **Faster Time to Market: **It's not uncommon for the integration and test/fix phase of the traditional phased software delivery lifecycle to consume weeks or even months. When teams work together to automate the build and deployment, environment provisioning, and regression testing processes, developers can incorporate integration and regression testing into their daily work and completely remove these phases. We also avoid the large amounts of re-work that plague the phased approach.

  * **Happier Team: **Peer-reviewed research has shown continuous delivery makes releases less painful and reduces team burnout. Furthermore, when we release more frequently, software delivery teams can engage more actively with users, learn which ideas work and which don't and see first-hand the outcomes of the work they have done. By removing the low-value painful activities associated with software delivery, we can focus on what we care about most--continuously delighting our users.

  * **Better Products: **Continuous delivery makes it economic to work in small batches. This means we can get feedback from users throughout the delivery lifecycle based on working software. Techniques such as A/B testing enable us to take a hypothesis-driven approach to product development whereby we can test ideas with users before building out whole features. This means we can avoid the 2/3 of features we build that deliver zero or negative value to our businesses.

  * **Higher Quality: **When developers have automated tools that discover regressions within minutes, teams are freed to focus their effort on user research and higher level testing activities such as exploratory testing, usability testing, and performance and security testing. By building a deployment pipeline, these activities can be performed continuously throughout the delivery process, ensuring quality is built into products and services from the beginning.

## Continuous Deployment vs. Continuous Delivery

Unlike [continuous deployment](https://www.agilealliance.org/glossary/continuous-deployment/), which deploys each change into production on a very frequent schedule, CD ensures that the software is deployable at any point during its lifecycle.

You can deploy to users with the push of a button. CD aims to automate the software delivery lifecycle until right before production; continuous deployment automatically deploys every code that passes the tests to production.

## DevOps/BizDevOps and CD

Much more than just combining development and operations, DevOps is a set of practices aimed at breaking down silos. BizDevOps is the next phase: it adds in business teams for further integration. CD, therefore, is a natural complement to BizDevOps.

One of the benefits of DevOps is its use of CD. But for CD to be effective, it needs to be adopted beyond just the development and operations teams. High-performing companies adopt CD practices across all products and services.

## How to Implement CD

It goes without saying, but the basics are important when you are first setting up a transition to CD.

  1. You need to evaluate what it will take, as well as review overall strategies and stakeholders' goals.
  2. Next, draw up a schedule of builds and maintenance release cycles; review builds' dependency management; and identify any gaps in technologies, tools, and processes.
  3. The next major phase involves CI and further defining the process. Develop a CI workflow and document the design flow. It should contain branching strategies, merging strategies, dependencies and multi-site coordination.
  4. Choose CI technologies and tools.
  5. Determine and document the timing for automation; with test automation, release cycles are shortened.

You're almost there! Now it's on to the deployment. Key steps include: breaking down the CI workflow into steps, automating the software builds, using a CI framework or building an automation tool to develop the packaging deployment scripts, and consistent reporting and tracking so as to facilitate troubleshooting.

This is the Continuous Delivery in a nutshell. In this article, we've covered many pros and cons of this approach and briefly described the benefits it can bring to your software development process. If you have any questions on the subject or need further help leave your comments in the sections below to start a conversation.

Watch [Avoiding the DevOps Tax](https://dzone.com/go?i=288426&u=https%3A%2F%2Fabout.gitlab.com%2F2018%2F03%2F21%2Favoiding-devops-tax-webcast%2F) to learn best practices for integration and automation to realize a faster DevOps lifecycle.
