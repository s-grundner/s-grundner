# Vorgehensmodell zur Softwareentwicklung

_Captured: 2015-10-23 at 00:45 from [de.m.wikipedia.org](https://de.m.wikipedia.org/wiki/Vorgehensmodell_zur_Softwareentwicklung)_

![](http://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Waterfall_model-de.svg/300px-Waterfall_model-de.svg.png)

> _Das Wasserfallmodell_

Da komplexe Software nur schwer zu erstellen und zu warten ist, bedienen sich [Softwareentwickler](https://de.m.wikipedia.org/wiki/Softwareentwickler) eines Planes zur Entwicklung von [Software](https://de.m.wikipedia.org/wiki/Software). Dieser Plan (das Vorgehensmodell) unterteilt den Entwicklungsprozess in uberschaubare, zeitlich und inhaltlich begrenzte Phasen. Die Software wird somit Schritt fur Schritt fertiggestellt. Der eigentliche Entwicklungsprozess wird dabei vom Projektmanagement und der Qualitatssicherung begleitet.

Vorgehensmodelle spalten einzelne Aktivitaten auf verschiedene Phasen im Entwicklungsprozess auf und diese werden dann - u. U. mit geringen Modifikationen - einmal (z. B. [Wasserfallmodell](https://de.m.wikipedia.org/wiki/Wasserfallmodell)) oder mehrmals durchlaufen (z. B. [Spiralmodell](https://de.m.wikipedia.org/wiki/Spiralmodell)). Bei mehrmaligen Durchlaufen erfolgt eine [iterative](https://de.m.wikipedia.org/wiki/Iteration) (d. h. wiederholte) Verfeinerung der einzelnen Softwarekomponenten. Um die optimalen Vorgehensmodelle herrscht Uneinigkeit. In der Regel unterscheiden sie beim Entwicklungsprozess mindestens zwei große Tatigkeitsgruppen: die (von der programmiertechnischen Realisierung unabhangige) Analyse von Geschaftsprozessen ([Geschaftsprozessmodell](https://de.m.wikipedia.org/wiki/Gesch%C3%A4ftsprozessmodell) und Datenmodell) einerseits und die EDV-technische Realisierung (Design und [Programmierung](https://de.m.wikipedia.org/wiki/Programmierung)) andererseits.

Vorgehensmodelle unterscheiden sich wesentlich in ihrem Detaillierungsgrad. [OOTC-Approach](https://de.m.wikipedia.org/w/index.php?title=OOTC-Approach&action=edit&redlink=1), [Rational Unified Process](https://de.m.wikipedia.org/wiki/Rational_Unified_Process), [Rapid Application Development](https://de.m.wikipedia.org/wiki/Rapid_Application_Development) etc. sind detailliert ausgearbeitete Vorgehensweisen, die den an der Entwicklung Beteiligten konkrete Arbeitsanweisungen an die Hand geben. Das [V-Modell](https://de.m.wikipedia.org/wiki/V-Modell) nimmt diesbezuglich ubrigens eine Zwitterstellung ein: Es ist sowohl ein Prinzip (jeder Stufe der Entwicklung entspricht eine Testphase) als auch (wie zumeist gebrauchlich) ein detailliertes Modell.

Die [Agile Softwareentwicklung](https://de.m.wikipedia.org/wiki/Agile_Softwareentwicklung) beschaftigt sich mit Methoden, die den Entwickler [kreativ](https://de.m.wikipedia.org/wiki/Kreativit%C3%A4t) arbeiten und Verwaltungsaspekte zurucktreten lassen. Alternative Softwaretechnologien ([Universal Application](https://de.m.wikipedia.org/wiki/Universal_Application), [Software factory](https://de.m.wikipedia.org/w/index.php?title=Software_factory&action=edit&redlink=1) u. a.) verfolgen Ansatze, welche die konventionelle Vorgehensweise von Softwareentwurf und anschließender Programmierung grundsatzlich in Frage stellen, indem vorgefertigte universalisierte Software per Konfiguration an die jeweiligen Anforderungen angepasst wird.

Es gibt verschiedene Bewertungsverfahren fur den Softwareprozess, u. a. das [Capability Maturity Model](https://de.m.wikipedia.org/wiki/Capability_Maturity_Model) (Integration) oder „[Spice](https://de.m.wikipedia.org/wiki/Spice_\(Norm\))".

Es gibt drei unterschiedliche Typen von Vorgehensmodellen:

**Softwareentwicklungsprozesse** dienen zur Steuerung einer Softwareentwicklung von der Konzeption bis zum Einsatz im Echtbetrieb inklusive der im Echtbetrieb anfallenden Änderungen einer Software. Eines der altesten Modelle ist das [Wasserfallmodell](https://de.m.wikipedia.org/wiki/Wasserfallmodell), das eine starre Abfolge der einzelnen Phasen annimmt. Weiterentwicklungen wie das [Spiralmodell](https://de.m.wikipedia.org/wiki/Spiralmodell) sehen hingegen Iterationen vor, d. h. derselbe Arbeitsschritt (z. B. die Analyse) wird mehrmals durchlaufen und die Ergebnisse des Arbeitsschrittes pro Durchlauf verfeinert und verbessert.

_Siehe auch: [Liste von Softwareentwicklungsprozessen](https://de.m.wikipedia.org/wiki/Liste_von_Softwareentwicklungsprozessen)_

**Softwarelebenszyklusmanagement** erweitert die Phasen uber den gesamten [Lebenszyklus einer Software](https://de.m.wikipedia.org/wiki/Software-Lebenszyklus). Das Vorgehensmodell definiert die Anforderungen an betriebliche Prozesse (das „WAS") und beschreibt die konkreten, EDV-technisch realisierten Prozesse (das „WIE"). Dieser Typ ist eine Mischung aus Ist-Beschreibung und normativer Vorgabe. Je nach Standardisierungsgrad werden verschiedene Entwicklungsstufen vergeben. Unternehmen konnen sich diese Entwicklungsstufen von externen Stellen zertifizieren lassen.

**Softwareentwicklungs-Philosophie** entspricht einer Programmierer-Philosophie, einem bestimmten Ansatz, wie Software nach Ansicht der [Proponenten](https://de.m.wikipedia.org/wiki/Proponent) _am besten_ entwickelt werden sollte. Diese Philosophien beinhalten sehr oft auch Prozesselemente und werden daher ebenfalls als Prozessmodell bezeichnet.
