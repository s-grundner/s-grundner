# Arrays.hashCode() Vs. Objects.hash()

_Captured: 2018-09-18 at 07:34 from [dzone.com](https://dzone.com/articles/arrayshashcode-vs-objectshash?edition=397198&utm_source=Daily%20Digest&utm_medium=email&utm_campaign=Daily%20Digest%202018-09-17)_

Since [JDK 1.5](http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html), the [Arrays class](https://docs.oracle.com/javase/10/docs/api/java/util/Arrays.html) has offered overloaded `static` methods with the name "`hashCode`" . Most of the overloaded methods accept an array of a particular primitive type, but the [Arrays.hashCode(Object[])](https://docs.oracle.com/javase/10/docs/api/java/util/Arrays.html#hashCode\(java.lang.Object%5B%5D\))method can be used to calculate an `int` hash code for an array of reference types. Since its [JDK 1.7 inception](https://www.javaworld.com/article/2074081/core-java/jdk-7--the-new-objects-class.html), the [Objects class](https://docs.oracle.com/javase/10/docs/api/java/util/Objects.html) has provided a method called [hash(Object...)](https://docs.oracle.com/javase/10/docs/api/java/util/Objects.html#hash\(java.lang.Object...\)) that also returns an `int` hash code for a provided array of Java objects (the [ellipsis](http://www.javawithus.com/tutorial/using-ellipsis-to-accept-variable-number-of-arguments) [`...`] representing [Java varargs](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs) is [handled as an array and accepts an array](https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html)). This post provides a brief comparison between `Arrays.hashCode(Object)` and `Objects.hash(Object...).`

We can look at the code in OpenJDK to see how OpenJDK implements the two methods being compared here. It turns out that `Arrays.hashCode(Object[])` and `Objects.hash(Object...)` behave exactly the same way, because `Objects.hash(Object...)` completely delegates to `Arrays.hashCode(Object[])`. This is shown in the next code listing extracted from the OpenJDK `Objects.java` class.

So, it turns out that the methods are really the same when one or more individual object references are passed. So, for many cases, whichever you choose is mostly a matter of taste. It may appeal to some to use the `Arrays` method directly, given that's what it is going to be called anyway. It is typically preferable to use the `Arrays` method when passing it a construct that is already known to be a Java array and to use the `Objects` method for situations where the values are being passed in a comma-separated combination without explicit array syntax being required, such as the case of implementing a custom class's `hashCode()` method and passing that class's attributes of arbitrary types for the hash code computation. When using an array of primitives of the same type, it is typically better to use the appropriate version of `Arrays.hashCode` for that particular primitive.

The simple class shown in the next code listing (and available on GitHub) demonstrates the differences and similarities in output between the overloaded versions of `Arrays.hashCode` and the `Objects.hash(Object...)` method.
    
    
          out.println("Objects.hash(Object...) for int[]:   " + Objects.hash(integers));  
    
    
          out.println("Objects.hashCode(Object) for int[]:  " + Objects.hashCode(integers));  
    
    
          out.println("Objects.hash(Object...) for Integer[]:   " + Objects.hash(refIntegers));  

The code shown above passes three common data sets -- an array of primitive `int` values, an array of reference `Integer` values, and an array of `String` values) to the methods `Arrays.hashCode`, `Objects.hash(Object...)`, and the [Objects.hashCode(Object)](https://docs.oracle.com/javase/10/docs/api/java/util/Objects.html#hashCode\(java.lang.Object\)) method that accepts a single [Object](https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html), of which an overall array qualifies. The simple example then writes the respective hash code values generated by each method for each data set to the standard output. The results of running this code are shown next.

As we would expect, `Arrays.hashCode(Object[])` and `Objects.hash(Object...)` return the same calculated hash code for the reference types `Integer` and `String` because they both effectively are the implementation of `Arrays.hashCode(Object[])`. The array of primitive `int` values leads to different results from `Arrays.hashCode(int[])` than from `Objects.hash(Object...)` , and this is, of course, because the array of primitives is passed to an overloaded `Arrays.hashCode(int[])` method, specifically implemented for that primitive data type rather than to `Arrays.hashCode(Object[])`.

If one compares the implementation of `Arrays.hashCode(int[])` to the implementation of `Objects.hash(Object...)` delegated to `Arrays.hashCode(Object[])`, the implementations look essentially the same in terms of logic. The reason for the different result in the case of an array of primitive `int` values passed to `Arrays.hashCode(int[])` when compared to the result from passing that same array of primitive `int` values to the `Objects.hash(Object...)` method is that the entire array of `int` values is treated as a single `Object` rather than as an array of individual objects when passed to `Objects.hash(Object...)`. Favor the appropriate overloaded `Arrays.hashCode` method for an array of primitives instead of using `Objects.hash(Object...)` and favor `Arrays.hashCode(Object[])` for arrays of reference types instead of using `Objects.hash(Object...)` to avoid compiler warnings and associated ambiguity.
